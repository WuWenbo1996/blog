# 面试流程

- **一面**：自我介绍（3～5分钟）、手撕代码、项目（10～15分钟）、基础知识【语言特点（面向对象）、设计模式、计算机网络、操作系统】（核心任务是手撕代码）

  1. 自我介绍：中文介绍3-5分钟，简要介绍学习经历、项目或实习经历即可
  2. 知识考查：主要包括计算机基础、通信知识、算法与数据结构等
  3. 代码考查：重点考查算法与数据结构，现场出题，手撕代码，即让你写出代码或伪代码，讲解解题思路、以及优化思路

  知识考查常见问题：进程线程区别，IPC方式，socket具体步骤，四次挥手过程等

  代码考查常见问题：常见排序方法、指针的相关概念，二叉树遍历相关知识、bfs，dfs的了解，二叉树按层遍历时需要注意什么？等等

- **二面**：自我介绍（3～5分钟）、项目、压力面试
  
  1. 自我介绍：中文介绍3-5分钟，简要介绍学习经历、项目或实习经历即可
  2. 知识考查：主要包括计算机基础、通信知识、算法与数据结构等
  3. 代码考查：重点考查算法与数据结构，现场出题，手撕代码，即让你写出代码或伪代码，讲解解题思路、以及优化思路（部分岗位2面无此环节）

- **主管面试**
  1. 项目经历、毕业设计的进展和功能规划
  2. 未来职业规划
  3. 意向地点、期望薪资（华为普通校招水平）
  4. 反问环节（具体工作内容）

# 面试考题

## 自我介绍

1. 秀优势，拿了什么奖，有什么荣誉。编程能力如何
2. 套近乎。对公司部分哪个部分比较感兴趣
3. 摆技术。说说擅长哪些技术

```
面试官好，我是吴温博，来自华南理工大学计算机科学与工程学院，目前正在攻读硕士学位。在校期间，我发表了一篇SCI论文和一篇中文核心论文，两份软著。另外还有一个专利正在受理中。我平时经常参加LeetCode编程竞赛和Kaggle平台大数据竞赛、以及实验室项目的数据平台开发和人工智能在电力应用的相关项目，并在GitHub上维护相关项目代码。在今年上半年我参与了南方电网电科院实习，针对项目传感器数据接收部分进行了优化，从原来的单进程到现在使用多线程方式接受各个传感器的数据，使系统内存在的无法短时间接收多台设备数据的问题得到了有效解决。因为研究生期间使用python比较多，所以对Python开发相关岗位感兴趣。
```

## Python

- 实现一个单例模式

  **单例模式（Singleton Pattern）**是一种常用的软件设计模式，该模式的主要目的是确保**某一个类只有一个实例存在**。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。

  比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。

  在 Python 中，我们可以用多种方法来实现单例模式

  **1. 使用模块**

  其实，**Python 的模块就是天然的单例模式**，因为模块在第一次导入时，会生成 `.pyc` 文件，当第二次导入时，就会直接加载 `.pyc` 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：

  **mysingleton.py**

  

  ```python
  class Singleton(object):
      def foo(self):
          pass
  singleton = Singleton()
  ```

  将上面的代码保存在文件 `mysingleton.py` 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象

  

  ```python
  from a import singleton
  ```

  **2. 使用装饰器**

  ```python
  def Singleton(cls):
      _instance = {}
  
      def _singleton(*args, **kargs):
          if cls not in _instance:
              _instance[cls] = cls(*args, **kargs)
          return _instance[cls]
  
      return _singleton
  
  
  @Singleton
  class A(object):
      a = 1
  
      def __init__(self, x=0):
          self.x = x
      def read(self):
          print(self.x)
  
  
  a1 = A(2)
  a2 = A(3)
  
  
  a1.read()
  a2.read()
  
  # 
  2
  2
  ```

  **3. 使用类**

  **4. 基于__new__方法实现（推荐使用，方便）**

  **5.基于metaclass方式实现**

- lambda表达式用过吗，你一般是怎么用它的

- 实现过哈希表吗，哈希表怎么实现的

- unordered_map和map的区别

- 实现一个装饰器

  装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短

  当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 

  装饰器让你在一个函数的前后去执行代码。

  **你的第一个装饰器**

  ```python
  def a_new_decorator(a_func):
   
      def wrapTheFunction():
          print("I am doing some boring work before executing a_func()")
   
          a_func()
   
          print("I am doing some boring work after executing a_func()")
   
      return wrapTheFunction
   
  def a_function_requiring_decoration():
      print("I am the function which needs some decoration to remove my foul smell")
   
  a_function_requiring_decoration()
  #outputs: "I am the function which needs some decoration to remove my foul smell"
   
  a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
  #now a_function_requiring_decoration is wrapped by wrapTheFunction()
   
  a_function_requiring_decoration()
  #outputs:I am doing some boring work before executing a_func()
  #        I am the function which needs some decoration to remove my foul smell
  #        I am doing some boring work after executing a_func()
  ```

  ```python
  @a_new_decorator
  def a_function_requiring_decoration():
      """Hey you! Decorate me!"""
      print("I am the function which needs some decoration to "
            "remove my foul smell")
   
  a_function_requiring_decoration()
  #outputs: I am doing some boring work before executing a_func()
  #         I am the function which needs some decoration to remove my foul smell
  #         I am doing some boring work after executing a_func()
   
  #the @a_new_decorator is just a short way of saying:
  a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
  
  print(a_function_requiring_decoration.__name__)
  # Output: wrapTheFunction
  # 这并不是我们想要的！Ouput输出应该是"a_function_requiring_decoration"。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。
  ```

  Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps

  ```python
  from functools import wraps
   
  def a_new_decorator(a_func):
      @wraps(a_func)
      def wrapTheFunction():
          print("I am doing some boring work before executing a_func()")
          a_func()
          print("I am doing some boring work after executing a_func()")
      return wrapTheFunction
   
  @a_new_decorator
  def a_function_requiring_decoration():
      """Hey yo! Decorate me!"""
      print("I am the function which needs some decoration to "
            "remove my foul smell")
   
  print(a_function_requiring_decoration.__name__)
  # Output: a_function_requiring_decoration
  ```

  规范

  ```python
  from functools import wraps
  def decorator_name(f):
      @wraps(f)
      def decorated(*args, **kwargs):
          if not can_run:
              return "Function will not run"
          return f(*args, **kwargs)
      return decorated
   
  @decorator_name
  def func():
      return("Function is running")
   
  can_run = True
  print(func())
  # Output: Function is running
   
  can_run = False
  print(func())
  # Output: Function will not run
  ```

  **注意：** **@wraps**接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。

  ---

  **拓展：使用场景**

  **授权(Authorization)**

  装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权：

  ```python
  from functools import wraps
   
  def requires_auth(f):
      @wraps(f)
      def decorated(*args, **kwargs):
          auth = request.authorization
          if not auth or not check_auth(auth.username, auth.password):
              authenticate()
          return f(*args, **kwargs)
      return decorated
  ```

  **日志(Logging)**

  ```python
  from functools import wraps
   
  def logit(func):
      @wraps(func)
      def with_logging(*args, **kwargs):
          print(func.__name__ + " was called")
          return func(*args, **kwargs)
      return with_logging
   
  @logit
  def addition_func(x):
     """Do some math."""
     return x + x
   
   
  result = addition_func(4)
  # Output: addition_func was called
  ```

  

- 用Python实现快排

- 如果系统中需要很多个Python版本，如何进行Python版本的管理

  虚拟环境：独立的环境，既可以同时安装特定版本的Python，也可以安装任何特定于项目的软件包，而不会影响任何其他项目。

  - **venv / pyvenv：**Python 3.3+版本中包含venv包。它是创建轻量级虚拟环境的理想选择。直到Python 3.6，一个被调用的脚本pyvenv也作为包装器被包含在内venv，但是这已被弃用。它将在Python 3.8中被完全删除。当使用venv时，可以使用完全相同的功能，并且应更新所有现有的文档。
  - **pyenv：**如果您希望在一台计算机上使用多个版本的Python，那么pyenv是在版本之间安装和切换的常用工具。
  - **pyenv-virtualenv：**pyenv可用于安装Python 2和3版本。但是，正如我们所看到的，venv仅限于大于3.3的Python版本。pyenv-virtualenv是一个创建与pyenv集成的虚拟环境的工具，适用于所有Python版本。

  **总结**

  1. 如果您使用单个版本的Python如3.3+版本，并且想要管理不同的虚拟环境，那么venv就是您所需要的。
  2. 如果你想使用多个3.3+版本的Python，不管是否有虚拟环境，那么请使用pyenv。
  3. 如果您还想使用Python 2，那么这pyenv-virtualenv是一个不错的选择。
- 如何实现一个全局变量？(除了global,还可以通过单例模式)

  ```python
  # global
  global a
  a = 3
  
  def Fuc():
      global a
      print a
      a = a + 1
  if __name__ == "__main__":
  　　global a
      for i in range(10):
          Fuc()
          print('hello')
      print a
  ```

  ```python
  # list
  a = [3]
  
  def Fuc():
      print(a[0])
      a[0] = a[0] + 1
  if __name__ == "__main__":
      global a
      for i in range(10):
          Fuc()
      print('hello')
      print(a[0])
  ```

- 在哪查看对象的所有属性和类

  使用dir命令

  ```python
  text="string"
  dir(text)
  ```

- python函数传值还是传引用

  python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。

- Python生成器与迭代器

  1. 迭代器

     迭代是Python最强大的功能之一，是访问集合元素的一种方式。

     迭代器是一个可以记住遍历的位置的对象。

     迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。

     迭代器有两个基本的方法：**iter()** 和 **next()**。

     字符串，列表或元组对象都可用于创建迭代器：

     ```python
     list=[1,2,3,4]
     it = iter(list)
     print(next(it))
     # 1
     print(next(it))
     # 2
     
     # 迭代器对象可以使用常规for语句进行遍历：
     list=[1,2,3,4]
     it = iter(list)    # 创建迭代器对象
     for x in it:
         print(x, end=" ")
         
     # 使用next()函数
     import sys         # 引入 sys 模块
     list=[1,2,3,4]
     it = iter(list)    # 创建迭代器对象
      
     while True:
         try:
             print(next(it))
         except StopIteration:
             sys.exit()
     ```

  2. 生成器

     在 Python 中，使用了 yield 的函数被称为生成器（generator）。

     跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

     在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

     调用一个生成器函数，返回的是一个迭代器对象。

     以下实例使用 yield 实现斐波那契数列：

     ```python
     import sys
      
     def fibonacci(n): # 生成器函数 - 斐波那契
         a, b, counter = 0, 1, 0
         while True:
             if (counter > n): 
                 return
             yield a
             a, b = b, a + b
             counter += 1
     f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
      
     while True:
         try:
             print (next(f), end=" ")
         except StopIteration:
             sys.exit()
     ```

- 函数重写函数重载是什么有什么区别

- private public protected

  对于继承自己的class，base class可以认为他们都是自己的子女，而对于和自己一个目录下的classes，认为都是自己的朋友。

  1、public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用
  2、private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。
  3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

- 深拷贝浅拷贝（举类内指针）

  - Python中对象的赋值都是进行对象引用（内存地址）传递
  - 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.
  - 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝
  - 对于非容器类型（如数字、字符串、和其他'原子'类型的对象）没有被拷贝一说
  - 如果元组变量只包含原子类型对象，则不能深拷贝

- 指针和地址区别

  1. 指针和地址最大的区别就是指针是有类型的，地址是没有类型的。我们当然可以通过绝对地址的方式找到函数和数据，但是地址是没有类型的，不能对地址进行算术操作，在涉及诸如数组等操作时就不能通过地址的自增和自减来访问数组的各个变量。
  2. 指针是由地址和类型两部分构成的，指向数据的指针不仅记录该数据的在内存中的存放的地址，还记录该数据的类型，即在内存中占用几个字节，这是地址所不具有的。

  指针是变量类型，它的值是地址，它作为变量是可以变化的。
  地址是一个数值而已

- 数组和指针区别

  1. 两者在含义上的区别。

     数组对应着一块内存区域，而指针是指向一块内存区域。其地址和容量在生命期里不会改变，只有数组的内容可以改变；而指针却不同，它指向的内存区域的大小可以随时改变，而且当指针指向常量字符串时，它的内容是不可以被修改的，否则在运行时会报错。

  2. 计算内存容量的区别。

     用运算符sizeof可以计算出数组的容量（字节数），而用sizeof却无法计算指针所指内存的容量，用sizeof(p)得到的结果永远是4或者2（即指针变量所占内存单元的字节数，一般情况下指针变量占2个或4个字节的内存单元）。在进行参数传递时，数组会自动退化为同类型的指针。

- 熟悉 Python、Python的回收机制

  - 自动内存回收方式1：引用计数

    若此对象无其他对象引用，则立马回收掉

    优点：简单、实时（将处理垃圾时间分摊到运行代码时，而不是等到一次回收）

    缺点：

    1.保存对象引用数会占用一点点内存空间

    2.每次执行语句都可能更新引用数，不再使用大的数据结构时，会引起大量对象被回收

    3.不能处理循环引用的情况

  - 自动内存回收方式2：标记-清除（Mark—Sweep）

    此方式主要用来处理循环引用的情况，只有容器对象（list、dict、tuple，instance）才会出现循环引用的情况

  - 何时触发

    1. 被引用为0时，立即回收当前对象
    2. 达到了垃圾回收的阈值，触发标记-清除
    3. 手动调用gc.collect()
    4. Python虚拟机退出的时候

- 理解面向对象思想，掌握 Python 继承、封装和多态特性

  ```python
  # 类： 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
  # 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
  # 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
  # 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
  # 实例变量：定义在方法中的变量，只作用于当前实例的类。
  # 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
  # 实例化：创建一个类的实例，类的具体对象。
  # 方法：类中定义的函数。
  # 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
  
  
  class Foo:
      def bar(self):
          print('bar')
  
      def hello(self, name):
          print('i am {}'.format(name))
  
  obj = Foo()
  obj.bar()
  obj.hello('admin')
  
  
  # 面向对象三大特性：封装、继承、多态
  
  # 封装：将对数据成员的访问限制在类的内部。
  # 封装的好处：
  # 1. 限制访问，只有内部才能访问
  # 2. 增加了类的结构，类的外部没有必要知道类的细节
  # 3. 增加了代码的可读性
  # 4. 增加了程序的可扩展性
  # 5. 增加了程序的可维护性
  # 6. 增加了程序的可测试性
  # 7. 增加了程序的可移植性
  # 封装的缺点：
  # 1. 增加了类的外部代码的复杂度
  
  class Foo:
      def __init__(self, name, age):
          self.name = name
          self.age = age
  
      def show_name(self):
          print(self.name)
  
  # 将数据封装到obj的name和age属性中
  obj = Foo('admin', 18)
  
  # 两种调用方式
  # 通过对象直接调用
  print(obj.name)
  # 通过self间接调用被封装的内容
  obj.show_name()
  
  
  
  # 继承：子类继承父类，子类除了拥有父类的所有功能外，还有一些更具体的特征。
  # 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。
  # 在python中继承中的一些特点：
  # 1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看： python 子类继承父类构造函数说明。
  # 2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数
  # 3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。
  
  class Animal:
      def __init__(self, name):
          self.name = name
  
      def run(self):
          print('{} is running'.format(self.name))
  
  class dog(Animal):
      def run(self):
          print('{} is running'.format(self.name))
  
  class cat(Animal):
      def run(self):
          print('{} is running'.format(self.name))
  
  # Python可以继承多个类, java只能继承一个类
  # 继承多个类，寻找方法的方式有两种：深度搜索和广度搜索
  # 当类是经典类，按照深度优先方式查找；当类是新式类(继承object类)，按照广度优先方式查找
  
  class Parent:        # 定义父类
      parentAttr = 100
      def __init__(self):
          print("调用父类构造函数")
  
      def parentMethod(self):
          print('调用父类方法')
  
      def setAttr(self, attr):
          Parent.parentAttr = attr
  
      def getAttr(self):
          print("父类属性 :", Parent.parentAttr)
  
  class Child(Parent): # 定义子类
      def __init__(self):
          print("调用子类构造方法")
  
      def childMethod(self):
          print('调用子类方法')
  
  c = Child()          # 实例化子类
  c.childMethod()      # 调用子类的方法
  c.parentMethod()     # 调用父类方法
  c.setAttr(200)       # 再次调用父类的方法 - 设置属性值
  c.getAttr()          # 再次调用父类的方法 - 获取属性值
  
  # 方法重写
  # 如果在子类中重写了父类的方法，那么在调用时就会调用子类的方法。
  class Parent:        # 定义父类
      def myMethod(self):
          print('调用父类方法')
  
  class Child(Parent): # 定义子类
      def myMethod(self):
          print('调用子类方法')
  
  c = Child()          # 子类实例
  c.myMethod()         # 子类调用重写方法
  
  # 基础重载方法
  # __init__、__str__、__cmp__
  class Vector:
      def __init__(self, a, b):
          self.a = a
          self.b = b
  
      def __str__(self):
          return 'Vector (%d, %d)' % (self.a, self.b)
  
      def __add__(self,other):
          return Vector(self.a + other.a, self.b + other.b)
  
  v1 = Vector(2,10)
  v2 = Vector(5,-2)
  print(v1 + v2)
  
  # 类的私有属性
  # __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
  # 类的方法
  # 在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数
  # 类的私有方法
  # __private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods
  class JustCounter:
      __secretCount = 0  # 私有变量
      publicCount = 0    # 公开变量
  
      def count(self):
          self.__secretCount += 1
          self.publicCount += 1
          print(self.__secretCount)
  
  counter = JustCounter()
  counter.count()
  counter.count()
  print(counter.publicCount)
  print(counter.__secretCount)  # 报错，实例不能访问私有变量
  
  # Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性，参考以下实例：
  class Runoob:
      __site = "www.runoob.com"
  
  runoob = Runoob()
  print(runoob._Runoob__site)
  
  
  # 单下划线、双下划线、头尾双下划线说明：
  # __foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。
  # _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *
  # __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。
  
  
  
  # 多态：由继承而产生了相关的不同的类，对同一个数据，在不同的场景下表现出不同的表现。让具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容(功能)的函数。
  # 多态特点：
  # 1、只关心对象的实例方法是否同名，不关心对象所属的类型；
  # 2、对象所属的类之间，继承关系可有可无；
  # 3、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；
  # 4、多态是调用方法的技巧，不会影响到类的内部设计。
  
  # 应用场景
  # 1. 对象所属的类之间没有继承关系，相互独立
  # 调用同一个函数fly(), 传入不同的参数（对象），可以达成不同的功能
  class Duck(object):                                  # 鸭子类
      def fly(self):
          print("鸭子沿着地面飞起来了")
  
  class Swan(object):                                  # 天鹅类
      def fly(self):
          print("天鹅在空中翱翔")
  
  class Plane(object):                                 # 飞机类
      def fly(self):
          print("飞机隆隆地起飞了")
  
  def fly(obj):                                        # 实现飞的功能函数
      obj.fly()
  
  duck = Duck()
  fly(duck)
  
  swan = Swan()
  fly(swan)
  
  plane = Plane()
  fly(plane)
  
  # 2. 对象所属的类之间有继承关系
  class gradapa(object):
      def __init__(self,money):
          self.money = money
      def p(self):
          print("this is gradapa")
  
  class father(gradapa):
      def __init__(self,money,job):
          super().__init__(money)                         # 调用父类的构造函数
          self.job = job
      def p(self):
          print("this is father,我重写了父类的方法")
  
  class mother(gradapa):
      def __init__(self, money, job):
          super().__init__(money)
          self.job = job
  
      def p(self):
          print("this is mother,我重写了父类的方法")
          return 100
  
  #定义一个函数，函数调用类中的p()方法
  def fc(obj):
      obj.p()
  gradapa1 = gradapa(3000)
  father1 = father(2000,"工人")
  mother1 = mother(1000,"老师")
  
  fc(gradapa1)            #这里的多态性体现是向同一个函数，传递不同参数后，可以实现不同功能.
  fc(father1)
  print(fc(mother1))
  ```

- list的底层数据结构、顺序表/链表

  Python中的list和tuple两种类型采用了顺序表的实现技术。Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序(即保序)

  **顺序表及链表**

  顺序表：将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。

  链表：将元素存放在通过链接构造起来的一系列存储块中。

  **顺序表及链表比较**

  1. 存取方式：顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。

  2. 逻辑结构与物理结构：顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻； 链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，其逻辑关系是通过指针链接来表示的。

  3. 查找、插入和删除：对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找。对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。

     顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需要修改相关结点的指针域既可。由于链表的每个结点都有指针域，所以在存储空间上要比顺序表付出的代价大，存储密度不够大。

  4. 空间分配：序存储在静态存储分配情况下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现溢出，所以需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表候补大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大的连续存储空间，则会导致分配失败

  **选择存储结构**

  1. 基于存储考虑

     难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。

  2. 基于运算考虑

     在顺序表中按序号访问元素的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，所以若经常做的运算是按序号访问数据元素，顺序表优于链表。但是如果在运算中需要进行大量的数据增加和删除操作的时候，链表优于顺序表。

  3. 基于环境的考虑

     顺序表容易实现，任何语言中都有数组的类型。链表的操作基于指针，会相对复杂些，逻辑性强一些。

## 数据库

- 数据库的数据是实时更新的吗？每点击一次，数据库数据修改一次？

- MYSQL和Redis的区别

  MySQL是关系型数据库,主要用于存放持久化数据,将数据存储在硬盘中,读取速度较慢。

  Redis是NOSQL,即非关系型数据库,也是缓存数据库,即将数据存储在缓存中,缓存的读取速度快,能够大大的提高运行效率,但是保存时间有限。

  **类型：**MySQL是关系型数据库,Redis是缓存数据

  **作用：**MySQL用于持久化的存储数据到硬盘,功能强大,但是速度较慢；Redis用于存储使用较为频繁的数据到缓存中,读取速度快

  **需求及使用场景：**MySQL和Redis配合使用，根据具体业务场景进行选型

  **数据存放位置：**MySQL数据放在磁盘，Redis数据放在内存

  **Redis使用场景：**Redis适合放一些频繁使用,比较热的数据,因为是放在内存中,读写速度都非常快,一般会应用在下面一些场景:排行榜、计数器、消息队列推送、好友关注、粉丝

  **数据库应用实际选择：**MySQL存储在磁盘里,Redis存储在内存里,Redis既可以用来做持久存储,也可以做缓存,而目前大多数公司的存储都是MySQL + Redis,MySQL作为主存储,Redis作为辅助存储被用作缓存,加快访问读取的速度,提高性能；Redis存储在内存中,如果存储在内存中,存储容量肯定要比磁盘少很多,那么要存储大量数据,只能花更多的钱去购买内存,造成在一些不需要高性能的地方是相对比较浪费的,所以目前基本都是MySQL**(主) + Redis(辅),**在需要性能的地方使用Redis,在不需要高性能的地方使用MySQL,好钢用在刀刃上；MySQL偏向于存数据,Redis偏向于快速取数据,但Redis查询复杂的表关系时不如MySQL,所以可以把热门的数据放Redis,MySQL存基本数据

- Redis hash的个数

  Redis 集群中内置了 **16384** 个哈希槽，当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点

  **集群的每个节点负责一部分hash槽**。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态

  使用哈希槽的好处就在于可以方便的添加或移除节点。当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务。

  一个hash slot中会有很多key和value，相当于表的分区。使用单节点时的redis时只有一个表，所有的key都放在这个表里；改用Redis Cluster以后会自动为你生成16384个分区表，你insert数据时会根据上面的简单算法来决定你的key应该存在哪个分区，每个分区里有很多key。

- 如何修改Redis数据库的库的个数？

  数据库的数量默认情况下是16个。

  **windows：**修改redis 目录下redis.windows.conf下的databases指令：databases 4。

  修改完重启命令：`redis-server.exe redis.windows.conf`

  **linux：**修改redis.conf文件中的database16，改成想要的数据库数量

- Redis数据库如何实现持久化

- Redis 有哪些数据结构？

  `String`、`Hash Tables`、`Linked Lists`、`Sets`、`Sorted Sets`

  - String

    是redis中最基本的数据类型，一个key对应一个value。

    String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。

    使用：get 、 set 、 del 、 incr、 decr 等

    实战场景：

    1.缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。

    2.计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。

    3.session：常见方案spring session + redis实现session共享，

  - Hash

    是一个Mapmap，指值本身又是一种键值对结构，如 value={{field1,value1},......fieldN,valueN}}

    使用：所有hash的命令都是 h  开头的   hget 、hset 、 hdel 等

    实战场景：

    1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。

  - Linked List

    List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。

    - lpush+lpop=Stack(栈)
    - lpush+rpop=Queue（队列）
    - lpush+ltrim=Capped Collection（有限集合）
    - lpush+brpop=Message Queue（消息队列）

    实战场景：

    1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。

  - Set

    集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. 不允许有重复的元素，2.集合中的元素是无序的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。

    使用：命令都是以s开头的 sset 、srem、scard、smembers、sismember

    实战场景：

    1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。

    2.点赞，或点踩，收藏等，可以放到set中实现

  - Sorted Set

    有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。

    实战场景：

    1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。

- Redis数据库支持的数据类型

- Redis使用AOF方式持久化，aof文件不断增大，如何处理？

- Redis数据库如何设置密码

  1. 配置文件有参数`requirepass`配置redis密码。**配置完后需要重启Redis**

  2. 如果不想重启Redis服务，可通过命令进行设置，`config set requirepass 123456`

     设置完成后，可通过指令查看密码，`config get requirepass`

     注：通过命令行修改了密码之后，配置文件（/etc/redis.conf）的requirepass字段后面的密码是不会随之修改的。

- hash表是如何生成的

- Redis 持久化机制？

- 缓存和数据库是如何实现同步的？

  缓存和数据库双写，采用预留缓存模式。读的时候，先读缓存，缓存没有再读数据库，然后取出数据后放入缓存，同时返回响应；更新的时候，先删除缓存，然后再更新数据库；这样读的时候就会发现缓存中没有数据而直接去数据库中读取数据。

- MySQL数据库如何使用sql语句插入一条数据

  ```sql
  insert into stu2(first_name, last_name, age, sex) values('赵', '六', 16, 1);
  delete from 表名 where 条件
  update 表名 set 要更新的字段名=值 where 条件
  # 模糊查询
  select * from 表名 where 字段名 like ’%值% ’
  ```

- MySQL数据库的慢查询有了解过吗

  分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“慢查询”。

  慢查询主要体现在慢上，通常意义上来讲，只要返回时间大于 >1 sec上的查询都可以称为慢查询。慢查询会导致CPU，内存消耗过高。数据库服务器压力陡然过大，那么大部分情况来讲，肯定是由某些慢查询导致的。

  MySQL在Windows系统中的配置文件一般是是my.ini找到[mysqld]下面加上

  ```ini
  # 慢查询日志存放的位置，一般这个目录要有MySQL的运行帐号的可写权限，一般都将这个目录设置为MySQL的数据存放目录；
  log slow queries = F:/MySQL/log/mysqlslowquery.log
  # 查询超过两秒才记录
  long_query_time = 2
  ```

- MySQL数据库如何进行查询优化

- 如何很多请求同时对Redis的同一个键进行访问，如何保证数据安全

  - 分布式锁

    让大家去抢锁，抢到锁就做`set`操作

    因为传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。

    当然，分布式锁可以基于很多种方式实现，比如zookeeper、redis等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。

    **分布式锁的要求**

    - 互斥性：在任意一个时刻，只有一个客户端持有锁。
    - 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
    - 容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁

    **分布式锁的实现：**Redis(setnx)

  - 消息队列

    在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。

    把Redis.set操作放在队列中使其串行化,必须的一个一个执行。

    这种方式在一些高并发的场景中算是一种通用的解决方案。

- 说说Redis的淘汰机制

- 我的MySQL数据库每天晚上12点进行全备份。第二天有员工在9点钟误删除了一个数据库，但在10点钟才被发现。问如何进行恢复被误删除的数据库并同时保留9点到10点钟新增的数据同时不影响业务的正常运行?

- 当数据越来越多，如何避免hash槽中key出现相同的情况?

- MongoDB在哪些场合使用过？

- session怎么存储，回答了redis相关。问了高并发怎么处理。数据库问有没有做过拆表。mysql怎么优化性能

- Acid问一致性怎么保证.项目开发问了产品迭代的问题，问怎么看项目追求完美还是有bug先上线再说

  执行事务。事务机制可以确保数据一致性。

  事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性

  - 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。【提交与回滚】
  - 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。【应用系统从一个正确的状态到另一个正确的状态【满足数据库层面的约束】.而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段】
  - 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
  - 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

- 数据库中left join right join有什么区别（结合饼状图交集来讲）

  left是左边的意思，join是连接的意思，连起来就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。

  right是右边的意思，join是连接的意思，加起来就是“右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据

- 数据库相关的数据结构

  MySQL底层索引是由`B+树`实现的。hash索引基于`哈希表`实现

- 你知道现在的那些大公司处理高并发场景是怎么处理的吗

- 负载均衡是怎么做的

- 数据库的范式？【三大范式】

  - **第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**

  - **第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）**

    **第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**

  - **第三范式（3NF）：在2NF基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（在2NF基础上消除传递依赖）**

    **第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

- mysql的主键，唯一索引区别，怎么建索引；

- mysql都有哪些索引类型；为什么b+树，红黑树、b树为什么不好；

- MyISAM 和 InnoDB 比较；

- mysql怎么实现主从复制？【binlog】

- redis缓存问题-雪崩，击穿

## Redis

- Redis

  Redis是一个开源的内存中的数据结构存储系统，它可以用作：**数据库、缓存和消息中间件**。**常见的数据结构类型有：String、List、Set、Hash、ZSet这5种**

  Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）

  Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。

  Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。

  数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。

  - Redis快

    Redis采用的是基于内存的采用的是**单进程单线程**模型的 **KV 数据库**

    1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

    2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

    3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

    4、使用多路I/O复用模型，非阻塞IO；

    5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

  - 多路 I/O 复用模型

    多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

    **这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

  - 为什么Redis是单线程的

    因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了

    这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行

  - Redis是用"单线程-多路复用IO模型"来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行。

    “我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU，或是让我们关键进程和一堆别的进程挤在一起。”。
    CPU 是一个重要的影响因素，由于是单线程模型，Redis 更喜欢大缓存快速 CPU， 而不是多核

    在多核 CPU 服务器上面，Redis 的性能还依赖NUMA 配置和处理器绑定位置。最明显的影响是 redis-benchmark 会随机使用CPU内核。为了获得精准的结果，需要使用固定处理器工具（在 Linux 上可以使用 taskset）。最有效的办法是将客户端和服务端分离到两个不同的 CPU 来高校使用三级缓存。

  - 其他IO模型

    1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；

    2、多进程模型：Oracle（Linux版本）；

    3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：

    （1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。

    （2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。

    （3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。

- redis和mysql一致性解决方案

- 一致性哈希的作用是什么

  `Redis`集群使用，为了保证`Redis`的高可用，提高`Redis`的读写性能，会做主从复制，进行数据的读写分离。

  **数据存储方式**

  1. 随机分配：由于规则是随机的，所有一条数据可能存在任意一组`Redis`中，因此需要遍历所有的`Redis`服务器
  2. Hash：可定位数据存储的服务器，相比随机分配，大大提升了性能
  3. 一致性Hash：当服务器数量变动时，所有缓存的位置都要发生改变。

  - 一致性哈希：该算法的原理用一句话将就是将服务器节点分布到一个环上，必要时需要增加虚拟节点（映射到真实节点），查找的时候根据Hash算法定位到环上的某个点，然后再顺时针找到最近的一个可用的服务器节点。

  - 一致性Hash算法的作用就是，使服务器失效或者新增时的影响范围达到最小。如果按照一般的直接根据服务器数量索引的，假设有4个服务器，两个用户ID分别为3和9，此时索引到的服务器为3号和1号。某个时候2号服务器失效，则用户将都被索引到原来的0号服务器，而该服务器是没有这两个用户的数据缓存的，就需要重新请求了。使用这种Hash方式，绝大部分情况下服务器失效或者新增都会导致用户被映射到不一样的服务器上，这样子就会导致所有用户均重新请求数据，从而导致缓存雪崩。而一致性Hash算法能够使的服务器失效或者新增只影响到这台服务器及其前面的一台服务器的用户数据，因为用户ID是顺时针找最近的服务器节点的。

## 项目部署

- 大家都说Nginx快？快的原因是什么？

  Nginx 采用的是多进程（单线程） & 多路IO复用模型。使用了 I/O 多路复用技术的 Nginx，就成了”并发事件驱动“的服务器。

  **多进程的工作模式：**Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程。master 接收来自外界的信号，向各 worker 进程发送信号，每个进程都有可能来处理这个连接。master 进程能监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动启动新的 worker 进程。注意 worker 进程数，一般会设置成机器 cpu 核数。因为更多的 worker 数，只会导致进程相互竞争 cpu ，从而带来不必要的上下文切换。使用多进程模式，不仅能提高并发率，而且进程之间相互独立，一个 worker 进程挂了不会影响到其他 worker 进程。使用多进程模式，不仅能提高并发率，而且进程之间相互独立，一个 worker 进程挂了不会影响到其他 worker 进程。

  **核心：Nginx 采用的 IO 多路复用模型 epoll**

  Nginx 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 accept() 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 worker 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。

- 为什么要nginx，直接连接不好吗？

  用Nginx反向代理是为了不让客户端知道真正访问的服务器地址是多少，以防止暴露服务器信息让服务器变的不安全。

  用nginx的目的一般是为了负载，分担后端各业务服务器的压力。

  反向代理分发请求可以平摊单个服务器的压力,单个服务没必要再代理

  nginx用来做分布式,分发请求, 还可以挂证书 多个不同的服务也可以挂一个域名上面 

  主要是这些 另外如果加了nginx还有其他功能比如gzip,限制连接,ip屏蔽

  静态文件也可以单独放nginx上面,nginx对静态文件读取处理得比较好

- 对RPC了解吗?

  - RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。
  - RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯） RPC 是一个请求响应模型。
  - 客户端发起请求，服务器返回响应（类似于Http的工作方式） RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

- 如何在服务器上设置业务进程数？

  1. 打开nginx的配置文件nginx.conf，我的是在/etc/nginx/nginx.conf路径下

  2. 然后配置参数

     ```ini
     #2核CPU，开启2个进程
     worker_processes     2;
     worker_cpu_affinity 01 10;
     ```

     worker_processes 是设置工作进程数数量
     worker_cpu_affinity 是分配工作进程在哪个cpu上
     双核的话就是01,10，代表了两个cpu
     01表示启用第一个CPU内核，10表示启用第二个CPU内核

     ```ini
     # 2核CPU,开启4个进程
     # 一个cpu上也可以绑两个进程哦
     worker_processes     4;
     worker_cpu_affinity 01 10 01 10;
     #4核CPU，开户4个进程
     worker_processes     4;
     worker_cpu_affinity 0001 0010 0100 1000;
     #4核CPU，开启2个进程
     worker_processes     2;
     worker_cpu_affinity 0101 1010;
     #8核CPU，开户8个进程
     worker_processes     8;
     worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;
     ```

- 说说正向代理和反向代理

  **正向代理**

  正向代理类似一个跳板机，代理访问外部资源。

  比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服务器，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了

  - **正向代理的用途**
    1. 访问原来无法访问的资源，如google
    2. 可以做缓存，加速访问资源
    3. 对客户端访问授权，上网进行认证
    4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

  **反向代理**

  反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

  - **反向代理的作用**
    1. 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网
    2. 负载均衡，通过反向代理服务器来优化网站的负载

  **总结**

  1. 正向代理中，proxy和client同属一个LAN，对server透明；
  2. 反向代理中，proxy和server同属一个LAN，对client透明。

## Linux

- 如何查看剩余内存

  ```bash
  free -m 
  ```

- 自己创建的用户在哪怎么知道是自己创建的、密码存在哪

  ```bash
  # 查看所有用户名
  cat /etc/passwd
  # 查看密码
  cat /etc/shadow
  ```

- 如何查看端口是否被占用

  1. 查看指定端口状态

     ```bash
     netstat -anp | grep 3306
     # tcp  0   0 0.0.0.0:3306     0.0.0.0:*  LISTEN    26661/mysqld 
     ```

     主要看监控状态为LISTEN表示已经被占用，最后一列显示被服务mysqld占用，查看具体端口号，只要有如图这一行就表示被占用了。

  2. 查看当前所有已经使用的端口情况

     ```bash
     netstat -nultp
     ```

  3. 可以看出并没有LISTEN那一行，所以就表示没有被占用。此处注意，图中显示的LISTENING并不表示端口被占用，不要和LISTEN混淆哦，查看具体端口时候，必须要看到tcp，端口号，LISTEN那一行，才表示端口被占用了

- linux 执行二进制文件过程

- 内核，用户态，内核态，怎么切换

- 进程线程协程

  **进程：**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是**操作系统进行资源分配和调度的一个独立单位**，是应用程序运行的载体

  - 进程一般由程序、数据集合和进程控制块三部分组成

    程序用于描述进程要完成的功能，是控制进程执行的指令集；

    数据集合是程序在执行时所需要的数据和工作区；

    程序控制块（Program Control Block，简称PCB），包含进程的描述信息和控制信息，是进程存在的唯一标志。

  - 进程特征：动态性、并发性、独立性、结构性

    **动态性：**进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

    **并发性：**任何进程都可以同其他进程一起并发执行；

    **独立性：**进程是系统进行资源分配和调度的一个独立单位；

    **结构性：**进程由程序、数据和进程控制块三部分组成

  **线程：**进程之间的切换开销较大，所以引出了线程。**线程是程序执行中的一个单一的顺序控制流程，是程序执行流的最小单位，是处理器调度和分派的基本单位。**

  - 一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。
  - 一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成。

  **进程和线程的区别**

  - 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位
  - 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
  - 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其他进程不可见；
  - 调度和切换：线程上下文切换比进程上下文切换要快得多

  **超线程技术**就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少CPU的闲置时间，提高CPU的运行效率

  操作系统采用时间片轮转的方式轮流执行每一个线程

  **用户线程与内核线程的对应关系模型**

  - 一对一模型：一个用户线程就唯一地对应一个内核线程。（反过来不一定成立，一个内核线程不一定有对应的用户线程)

    **优缺点**

    - 一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响，因此可以让多线程程序在多处理器的系统上有更好的表现；

    - 但许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制。许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程执行效率下降

  - 多对一模型：多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。

    **优缺点**

    - 因此相对一对一模型，**多对一模型的线程上下文切换速度要快得多；此外，多对一模型对用户线程的数量几乎无限制**
    - 如果其中一个用户线程阻塞，那么其他所有线程将都无法执行，因为此时内核线程也随之阻塞了
    - 在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了；

  - 多对多模型**【大部分流行的操作系统采用】**：多对多模型结合了一对一模型和多对一模型的优点，**将多个用户线程映射到多个内核线程上。**由线程库负责在可用的调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。

    **优缺点**

    - 一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；多对多模型对用户线程的数量没有限制；
    - 在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高

  **进程的生命周期**

  进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程

  - 创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；
  - 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来
  - 运行：此线程正在执行，正在占用时间片；
  - 阻塞：也叫等待状态，等待某一（如IO或另一个线程）执行完；
  - 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源

  **线程的生命周期**

  - 创建：一个新的线程被创建，等待该线程被调用执行；
  - 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；
  - 运行：此线程正在执行，正在占用时间片；
  - 阻塞：也叫等待状态，等待某一（如IO或另一个线程）执行完；
  - 退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源

  **协程：**是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做`用户空间线程`，具有对内核来说不可见的特性

  因为是自主开辟的异步任务，所有也叫它`纤程`，或者`绿色线程`。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程

  **协程的目的：**基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时，如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态。**协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务。**

  - **系统线程会占用非常多的内存空间**
  - **过多的线程切换会占用大量的系统时间**
  - **协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**

  **协程的特点：**线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率；由于在同一个线程上，因此可以避免竞争关系而使用锁；适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程。

  **协程原理：**当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑。

  由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。

  因此，协程的开销远远小于线程的开销，也就没有了上下文切换上的开销。

  **协程的注意事项**

  协程只有在等待IO的过程中才能重复利用线程，上面我们已经讲过了，线程在等待IO的过程中会陷入阻塞状态，意识到问题没有？

  假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，**因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。**因此在协程中不能调用导致线程阻塞的操作。也就是说，**协程只有和异步IO结合起来，才能发挥最大的威力**。在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。

  那么如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：

  1. **在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。这其实和多线程没有太大区别。**
  2. **对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。**

- 进程通信方式，哪种最高效

  **内存共享**，在虚拟地址空间中堆和栈地址空间的中间的共享映射区中开辟一块地址，然后由页表和内存管理单元在物理内存中开辟一段空间，其他进程如果获取到了这个内存的ID便可以和另外的进程共享这段内存。

  比其他的进程间通信的方式都要高效，因为它直接看到的就是内存

- 进程同步方式

  - 信号量

    一种最为简单和直观的方法是直接制约的进程互相给对方进程发送执行条件已经具备的信号。这样，被制约进程即可省去对执行条件的测试，只要收到了制约进程发来的信号便开始执行，而在未收到制约进程发来的信号时便进入等待状态。

  - P、V原语

    - P操作：p(s)是一个原语操作，p操作执行 s– ，若s为负数，调用p(s)的进程被阻塞，放到等待队列q中。
    - V操作：v(s)刚好与p(s)操作相反，v操作执行 s++ ，若s为大于0，继续执行;s <=0,从信号灯等待队列移出一个进程，解除等待状态，返回本程序继续执行。

    - 使用P、V原语操作实现进程间的同步，分为3步：
      1. 首先为各并发进程设置私用信号量
      2. 然后为私用信号量赋初值
      3. 最后利用P、V原语和私用信号量规定各进程的执行顺序

  - 生产者-消费者模型

    并发进程同步和互斥问题，一般都可以抽象为生产者-消费者问题。

- 谈谈虚拟内存

  虚拟内存技术，可让系统看上去具有比实际物理意义内存大的多的内存空间，并为实现多道程序的执行创造了条件。**实际上计算机所配置内存的实际空间常常小于处理器的寻址范围。**把要运行的那一段程序自辅存复制到内存中来运行，而其他暂时不运行的程序段就让它仍然留在辅存。**经过不断有目的的换入和换出，处理器就可以运行一个大于实际物理内存的应用程序了。**

  **计算机虚拟内存空间的大小是由程序计数器的寻址能力来决定的。**

  由于存在两个内存地址，因此一个应用程序从编写到被执行，需要进行两次映射。**第一次是映射到虚拟内存空间，第二次时映射到物理内存空间。在计算机系统中，第两次映射的工作是由硬件和软件共同来完成的。承担这个任务的硬件部分叫做存储管理单元MMU，软件部分就是操作系统的内存管理模块了。**

  **以存储单元为单位来管理显然不现实，因此Linux把虚存空间分成若干个大小相等的存储分区，Linux把这样的分区叫做页。于物理内存中的块空间是用来容纳虚存页的容器，所以物理内存中的块叫做页框。**

  - 虚拟内存的页、物理内存的页框及页表
  - 请页与交换
  - 快表
  - 页的共享
  - 页的保护
  - 多级页表
  - Linux的页表结构

- linux 创建进程

  **进程空间分布：【low->high】**代码段->数据段（初始化过的数据、未初始化过的数据）->堆（内存动态内存分配，需要手动分配释放，分配方式类似于链表）->用户栈（局部、临时变量）->共享段

  一个现有进程可以调用**fork()**函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。父子进程间不共享这些存储空间。

  vfork（）会产生一个新的子进程。但是vfork创建的子进程与父进程共享数据段,而且由vfork创建的。子进程将先于父进程运行。

- 如何查看一个程序的PID以及它的所有子进程

  ```bash
  # 得到进程的pid
  ps -ef | grep process_name | grep -v "grep" | awk '{print $2}'
  ```
  
- 一行命令kill进程

  ```bash
  # 常规操作
  ps -ef | grep python3 
  kill -9 4678
  
  # 一行kill
  ps -ef | grep device.py | grep -v grep | awk '{print $2}' | xargs kill -9
  # 列出进程信息
  ps -ef
  # 在进程信息中找到需要杀死的进程命令名
  grep device.py
  # 在进程信息中剔除带 grep 的信息（也就是剔除 grep 命令的进程，避免误删）
  grep -v grep
  # 提取字符串行内容的第2个字段，也就是当前示例的进程号
  awk '{print $2}'
  # 将进程号作为参数传递给kill -9这个命令
  xargs kill -9
  ```

- 如何为一个目录下的所有文件添加权限

  ```bash
  # 对一个目录src及其子目录所有文件添加权限命令
  chmod 777 -R ./html
  # 给予html目录下可读可写可操作权限
  chmod -R u+x ./html
  ```

- 如果你对一个目录具有写权限，那么你是否具有对这个目录下的所有文件具有删除权限？

- 对Linux多路复用的理解

- 修改IP地址的方法 

- 熟悉 Linux 下常用命令,会使用 find、grep、xargs, 了解软硬连接文件

  可以对文件做硬链接，不能对目录做硬链接；

  **软连接：**软链接又叫符号链接（symbolic link），本身是一个文件，类似于Windows下的快捷方式，可以通过连接文件转到原文件，即访问原文件的内容。对一个软链接文件进行操作，其实质是操作原文件。软链接的原文件是不能删除的，否则软链接文件就失效了

  **硬连接：**硬链接删不删原文件是不受影响的

  **find**：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件。

  ```bash
  find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
  # 其实[-H] [-L] [-P] [-D debugopts] [-Olevel]这几个选项并不常用（至少在我的日常工作中，没有用到过），上面的find命令的常用形式可以简化为:
  find [path...] [expression]
  
  # 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:
  find . -name "*.c"
  # 将当前目录及其子目录下所有最近 20 天内更新过的文件列出
  find . -ctime -20
  ```

  **grep：**grep 命令用于查找文件里符合条件的字符串。

  ```bash
  # 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行
  grep test *file 
  ```

  **xargs：**xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。

  xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。

  xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。

  xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。

  xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。

  ```bash
  find /sbin -perm +700 |xargs ls -l
  ```

- Linux ps 命令

  `ps`命令能够给出当前系统中进程的快照，捕获系统在某一时间的进程状态

  ```bash
  # 显示内容（PID: 运行着的命令(CMD)的进程编号 TTY: 命令所运行的位置（终端）TIME: 运行着的该命令所占用的CPU处理时间 CMD: 该进程所运行的命令）
  ps
  # 显示所有当前进程，-a代表all，x参数会显示没有控制终端的进程
  ps -ax
  # 根据用户过滤，查看特定用户user进程
  pu -u userName
  # 通过cpu和内存使用来过滤进程，使用--sort来排序
  ps aux
  ps aux --sort -pcpu
  ps aux --sort -pmem
  # 管道显示前10个结果
  ps aux --sort -pcpu,+pmem | head -n 10
  # grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
  ps aux | grep ./update_stock
  ```

- 熟悉 Linux 下` vim` 等编程工具

  vim有四个模式：正常模式、插入模式、命令模式、可视模式（正常模式下按v）

  ```bash
  # 打开文件
  vim file
  # 打开多个文件
  vim file1 file2
  # 命令模式
  :w	# 保存当前对文件的修改，但是不退出文件
  :wq	# 退出文件并保存对文件的修改
  :q	# 退出文件，:q!退出文件，对文件的修改不做保存
  
  # 插入模式
  # i是在光标所在的字符之前插入需要录入的文本。
  # I 是在光标所在行的行首插入需要录入的文本。
  # a 是在光标所在的字符之后插入需要录入的文本。
  # A 是在光标所在行的行尾插入需要录入的文本。
  # o 是光标所在行的下一行行首插入需要录入的文本。
  # O 是光标所在行的上一行行首插入需要录入的文本。
  # s 删除光标所在处的字符然后插入需要录入的文本。
  # S 删除光标所在行，在当前行的行首开始插入需要录入的文本。
  
  # 命令模式
  :set nu	# 显示行号
  :set nonu # 取消行号
  :n	# 定位到n行
  
  /{目标字符串} # 在文本中匹配出高亮。输入n寻找下一个匹配，N寻找上一个匹配。例：/zempty会在文本中匹配zempty的地方高亮
  :set ic	# 编辑器将不会区分大小写，例如关键词查询/zempty，ZeMpty, zEmpty也是符合条件的
  :set noic # 区分大小写的查询
  :n1,n2d	# n1和n2指的是起始行号和结束行号，d是删除关键字
  
  :{作用范围}s/{目标}/{替换}/{替换的标志} # 作用范围分为当前行、全文、选区等等
  :s/zempty/handsome/g	# 将会把当前光标所在行的zempty替换成handsome
  :%s/zempty/handsome/g	# 将会把全文的zempty替换成handsome
  :n1,n2s/zempty/handsome/g	# 这里的n1,n2为行号，将会替换掉n1到n2的所有zempty为handsome
  # 上文中命令结尾的g为替换标志之一，表示全局global替换
  :s/zempty/handsome	# 空替换标志表示只替换从光标位置开始，第一次出现的目标
  :%s/zempty/handsome # 作用于当前行，从光标处开始查找替换，将第一次匹配zempty的地方替换为handsome
  :%s/zemtpy/handsome/i # i表示大小写不敏感查找，I表示大小写敏感
  :%s/zempty/handsome/gi	# 替换掉所有行出现zempty(不区分大小写)为handsome
  :%s/zempty/handsome/gc	# c表示需要确认，全局查找zempty并需要确认
  
  # vim中执行Linux命令，执行完命令后Enter返回到文件
  :!Command
  :!date	# 执行date显示系统时间
  :r !Command	# 执行命令，并且添加结果至操作文本光标处
  :r !date
  
  # 正常模式
  # h, j, k, l用来快速移动光标
  # h是向左移动光标，l是向右移动光标, j是向下移动光标，k是向上移动光标。可以用来代替键盘的上下左右键。
  
  # 在当前行上移动光标
  0 # 移动到行头
  ^ # 移动到本行的第一个不是 blank 字符
  $ # 移动到行尾
  g_ # 移动到本行最后一个不是 blank 字符的位置
  w # 光标移动到下一个单词的开头
  e # 光标移动到下一个单词的结尾
  fa # 移动到本行下一个为 a 的字符处，fb 移动到下一个为 b 的字符处
  nfa # 移动到本行光标处开始的第 n 个 字符为 a 的地方（n 是 1，2，3，4 ... 数字）
  Fa # 同 fa 一样，光标移动方向同 fa 相反
  nFa # 同 nfa 类似，光标移动方向同 nfa相反
  ta # 移动光标至 a 字符的前一个字符
  nta # 移动到第二个 a 字符的前一个字符处
  Ta # 同 ta 移动光标方向相反
  nTa # 同 nta 移动光标方向相反
  # ; 和, 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 ；可以快速跳转到写一个指定的字符，, 是跳到前一个指定的字符
  
  # 跨行移动光标
  nG # 光标定位到第 n 行的行首
  gg # 光标定位到第一行的行首
  G # 光标定位到最后一行的行首
  H # 光标定位到当前屏幕的第一行行首
  M # 光标移动到当前屏幕的中间
  L # 光标移动到当前屏幕的尾部
  zt # 把当前行移动到当前屏幕的最上方，也就是第一行
  zz # 把当前行移动到当前屏幕的中间
  zb # 把当前行移动到当前屏幕的尾部
  % # 匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上
  # * 和 # 匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ * 是下一个，# 是上一个）
  
  # 翻页操作
  ctrl+f # 查看下一页内容
  ctrl+b # 查看上一页内容
  
  # vim的复制，黏贴和删除
  # 三个重要的快捷键d, y, p
  # d 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：
  dw # 删除一个单词
  dnw # 删除 n 个单词，
  dfa # 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）
  dnfa # 删除光标处到第 n 个 a 的字符处
  dd # 删除一整行
  ndd # 删除光标处开始的 n 行
  d$ # 删除光标到本行的结尾
  dH # 删除屏幕显示的第一行文本到光标所在的行
  dG # 删除光标所在行到文本的结束
  # y 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：
  yw # 复制一个单词，还有 ynw
  yfa # 复制光标到下一个 a 的字符处,还有ynfa
  yy # 复制一行，还有 nyy
  y$ # 复制光标到本号的结尾
  yH # 复制屏幕显示的第一行文本到光标所在的行
  yG # 复制光标所在行到文本的结束
  # p, P是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来。
  p # 在光标后开始复制
  P # 大写的 P 光标前开始复制
  
  # 撤销操作和恢复
  u # 撤销刚才的操作
  ctrl + r # 恢复撤销操作
  
  # 删除字符操作和替换
  x # 删除光标当前所在的字符
  r # 替换掉光标当前所在的字符
  R # 替换掉从光标开始以后的所有字符，除非 <ESC > 退出，或者 jj （代替 <ESC> 上文有提到）退出
  
  # 大小写转换
  ~ # 将光标下的字母改变大小写
  3~ # 将光标位置开始的3个字母改变其大小写
  g~~ # 改变当前行字母的大小写
  gUU # 将当前行的字母改成大写
  guu # 将当前行的字母全改成小写
  3gUU # 将从光标开始到下面3行字母改成大写
  gUw # 将光标下的单词改成大写。
  guw # 将光标下的单词改成小写
  
  # 重复命令(n<Command>)
  10p		# 复制10次
  10dd	# 删除10次
  
  # vim代码提示功能
  ctrl+n
  ctrl+p
  ```

- 熟悉 Linux 下进程环境和进程间通信(signal、file、pipe、shm、sem、msg)、socket

  linux下进程间通信的几种主要手段简介：

  1. 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
  2. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本 身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于 BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
  3. 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。
  4. 共享内存：使得多个进程可以访问同一块内存空间，是**最快的可用IPC形式**。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
  5. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
  6. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

  多线程间要通信，应该怎么做？前面已经说了，多数的多线程都是在同一个进程下的，它们共享该进程的全局变量，我们可以通过全局变量来实现线程间通信。如果是不同的进程下的2个线程间通信，直接参考进程间通信。

- 了解 Linux 下多进程、多线程、线程池、并发网络服务

  - **多进程网络服务**

    多进程网路服务模式是利用LINUX系统中的父子进程关系为多用户提供并发服务，是一种比较流行的并发服务技术，其基本理念是来一个用户，启动一个服务进程。

    - **实现原理**

      多进程网络服务模式的实现原理是：主要服务在端口进行绑定侦听，同时设置被绑定的地址与端口是可重用的（注：这种设置是基础，因为存在多个进程要在同一个端口进行侦听），启动侦听。若当前有新连接到来，则启动以个子进程与其交互，服务结束后子进程自动退出。

    - 优缺点

      多进程网络服务模式的优点是方法通用，有很多成功的服务软件均采用这种模式。缺点是每次启动并关闭子进程会带来很大的开销，在大用户量并发的前提下，会产生不小的负担，另外父子进程间的数据共享、同步等具体逻辑实现上也会有一定的困难。
      在实际商用环境下，这是一种可选的模式。

  - **多线程网络服务**

    多线程网络服务模式类似于多进程网络服务模式，不同之处为多线程是新到一个客户，连接启动一个服务线程多。由于线程比进程损耗资源小，所以多线程效率一般高过多进程。多线程是LINUX的一大优势，多线程网络服务程序应用比较广泛。

    - 实现原理

      在主服务线程里进行阻塞式等待，在绑定的端口进行侦听：若当前有连接到来，则启动一个新线程为其服务，服务结束后，释放线程资源。

    - 优缺点

      正如前面所讲，多线程网络服务程序应用比较广泛，它的优点是便捷、高效，缺点是仍存在动态线程申请与释放，还是有一定的开销，若存在大用户量在线，可能会带来很大的线程间切换开销。
      在实际商用环境中，这是一种可行的模式。

  - **线程池网络服务**

    线程池网络服务时针对多线程网络服务模式的一些不足之处而提出的改进模式。池是在实际工程中非常流行的一个概念，如多线程池、数据库连接池等，基本理念是先创建一批资源，当有用户到来时，直接分配已创建好资源，它的主要目的是减少系统在频繁创建资源时的开销。

    - 实现原理

      线程池网络服务模式的实现原理是：主服务线程创建既定数量的服务线程，同时在指定端口进行侦听，若当前有新连接到来，则从线程池中找出空闲的服务线程，为其服务，服务完毕，线程不进行释放，重新放回线程池；若当前线程池已满，则将当前的连接加入等待队列。

    - 优缺点

      线程池网络服务模式的优点是性能高效，在实际商用环境下，很多都会采用这种模式。缺点是新用户如果在等待服务队列里耗时过长，会影响用户体验，针对此问题，有两种改进方案：
      1、动态创建新的服务线程，服务结束后，该线程加入到线程池，这种改进得好处是用户体验得到提升，但潜在得问题是线程得规模在长时间、大并发用户的状态下，会变得很大，最后会产生因资源消耗过多，系统退出。
      2、增加一个线程资源回收机制，当线程池得规模达到一定程度或满足某种既定规则时，会主动杀死一些线程，以达到在用户体验与系统运行稳定性之间得折中。

- 了解 Linux I/O 复用 select、poll、epoll 高并发模型

  **什么是IO多路复用**

  文件描述符(fd) 表示的是对某个文件操作的句柄。当然socket套接字也算是fd。一般来说，想对fd进行读写操作，就要操作到fd，例如 read()，但read()本身是BIO，即阻塞IO，当对fd调用read()时，如果暂时没有数据输入到fd，那么read()将会处于阻塞状态，直到有数据输入，read()才会返回。

  那么我们就可以想，如果现在有一个客户端连接进服务器，想要跟服务端通信，那么服务端就 对表示这个服务器的 sd(socket也能当作fd)，调用read()，此时，若客户端有信息进入，read()返回，否则，read()会一直阻塞。

  那么如果有两个客户端连接进来了，也想跟服务器通信，那怎么办呢？答案是开多一条线程，让另一个线程对第二个客户端调用read()，并阻塞到客户端有信息进入服务器为止。那这样就出现问题了，实际应用中，客户端不可能只有几个啊，可能有上万个客户端想要跟服务端通信，那么也要开上万个线程？那显然是不实际的。

  所以解决方法就是 IO多路复用。IO多路复用一般有 select()、poll()、epoll()方式，他们都是对连接进服务端的 客户端socket就行监控，例如现在有100个 客户端socket，那么就监控这100个，如果这100个socket中有信息进入，则IO多路复用会返回，否则，就阻塞。即IO多路复用可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写（就是监听多个socket）。

  正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。
  **select、poll、epoll的区别和总结**

  IO多路复用一般分为：select、poll、epoll 三种方式。三个都属于系统调用。

  - select

    |                                  | 应用进程   |              | 内核         |
    | -------------------------------- | ---------- | ------------ | ------------ |
    | 系统受阻于select调用             | select     |              | 无数据准备好 |
    | 等待多个文件描述符中任意一个返回 |            | 返回可读条件 | 数据准备好   |
    | 系统拷贝数据进程，进程阻塞       | Read       |              | 拷贝数据     |
    |                                  | 处理数据包 | 返回成功指示 | 拷贝数据完成 |

    用户进程调用 select() 监控用户指定的多个文件描述符，若没有一个文件描述符有数据返回，则阻塞，若有文件描述符有数据返回，则会对这个文件描述符调用read()进行读取数据。

    int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    上面的 readfds、writefds、exceptfds 都是要监控的文件描述符的集合，这些集合在调用 select 前后是会发生变化的，

    前：表示关心的文件描述符集合

    后：有数据的集合（如不是在超时返回的情况下）

    换句话说就是：我们先是设置了要监控的各个I/O的文件描述符到fd_set集合，然后调用select()，最后fd_set集合只剩下有"异常"（包括读、写、异常）的文件描述符，举例就是，select前，readfds里的是 要监控的文件描述符的集合，select后，readfds里的则是 有数据信息进入的文件描述符的集合。

    注意: fd_set全是位图，位图就是只有0、1值的数组。  三组fd_set均将某些fd位置0，只有那些可读，可写以及有异常条件待处理的fd位仍然为1。由于 select的底层是位图，位图是数组，所以select所能监控的文件描述符的数量是有上限的，因为数组就是定长的嘛。

    **select 的缺点：**

    1. 内核/用户数据拷贝频繁，操作复杂。

    在调用 select() 之前，需要手动在 程序中 维护一个包含要监控的文件描述符的 文件描述符集合 fd_set。把需要监听的文件描述符加到fd_set中。用户为了检测时间是否发生，还需要在用户程序手动维护一个数组，存储监控文件描述符。当内核事件发生，在将fd_set集合中没有事件发生的文件描述符清空，然后拷贝到用户区，和数组中的文件描述符进行比对。再调用select也是如此。每次调用，都需要来回拷贝。

    2. 单个进程监控的文件描述符有限，通常为1024*8个文件描述符

    3. 轮询时间效率低

    select 检测时间是否发生的方式是通过轮询各个 文件描述符。当文件描述符的数量大的时候，轮询的效率很低，所以select 监控时的时间复杂度为O(n)。

  - poll

    不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。

    ```c
    int poll (struct pollfd *fds, unsigned int nfds, int timeout);
    ```

    不同于select的位图方式，poll是通过设置结构体pollfd(如下)中fd和 event 参数来实现read/write，比如读为POLLIN，写为POLLOUT，出错为POLLERR

    ```c
    struct pollfd {
        int fd; /* file descriptor */
        short events; /* requested events to watch，eg:POLLIN\POLLOUT\POLLERR */
        short revents; /* returned events witnessed */
    };
    ```

    而且poll 没有文件描述符的数量限制，因为poll() 内部是使用链表进行记录，而 select() 是使用的bit位序列(位图)进行记录。

    优缺点：

    1. 相对于select，poll 没有监听文件描述符的数目上限。

    2. 由于 poll 监听文件描述符的方式都是轮询，跟select 一样，所以 poll 在高并发下的表现也不是特别好。

    从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

    所以对于poll来说，select的大部分问题，poll都具有。拿select为例，加入我们的服务器需要支持100万的并发连接。则在FD_SETSIZE(最大fd连接数)为1024的情况下，我们需要开辟100个并发的进程才能实现并发连接。除了进程上下调度的时间消耗外。从内核到用户空间的无脑拷贝，数组轮询等，也是系统难以接受的。因此，基于select实现一个百万级别的并发访问是很难实现的。

  - epoll

    select、poll监听文件描述符的方式是轮询，epoll是通过**回调函数**，采用回调的方式，只有**活跃可用**的fd才会调用callback函数，也就是说 epoll 只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。

    **epoll 与 select/poll 的流程对比**

    select在每次被调用之前，都要把要监控的文件描述符fd加到监控的集合(也可以叫做等待队列)，然后再调用select阻塞，直到有fd返回。这是select低效的原因之一------将“维护等待队列”和“阻塞进程”两个步骤合二为一。而epoll 则把这两个步骤分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程（解耦）。显而易见的，效率就能得到提升。

    **epoll的大致工作流程**

    我们在调用epoll_create时，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的文件描述符fd，当epoll_wait调用时，仅仅观察这个rdllist双向就绪链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。

      所有添加到epoll中的 fd 都会与设备(如网卡)驱动程序建立回调关系，也就是说相应 fd 的监听事件 发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的 fd 放到上面的rdllist双向就绪链表中。

    **epoll 特点：**

    - 没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存能监听约10万个端口）

    - 采用回调的方式，效率提升。只有活跃可用的fd才会调用callback函数，也就是说 epoll 只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。

    - 内存拷贝。使用mmap()文件映射内存来加速与内核空间的消息传递，减少复制开销。

      |            | select                                             | poll                                             | epoll                                                        |
      | ---------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
      | 操作方式   | 遍历                                               | 遍历                                             | 回调                                                         |
      | 底层实现   | 数组                                               | 链表                                             | 红黑树+链表                                                  |
      | IO效率     | 每次调用都进行线性遍历，时间复杂度为`O(n)`         | 每次调用都进行线性遍历，时间复杂度为`O(n)`       | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面，时间复杂度`O(1)` |
      | 最大连接数 | 1024或2048                                         | 无上限                                           | 无上限                                                       |
      | fd拷贝数   | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | 调用poll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝     |

## 操作系统

- 文件系统FAT32结构？

- 操作系统打开文件夹，是怎么打开的，window打开文件夹大概是怎么实现的？

- 内存怎么管理？页表 段表 段页表

- 为什么使用虚拟内存？

- 内存管理，页面置换算法

  - LRU（最近最少使用）

    选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。

  - OPT（最佳置换算法）

    这是一种理想情况下的页面置换算法，但实际上是不可能实现的。该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。最佳页面置换算法只是简单地规定：标记最大的页应该被置换。这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。

  - FIFO（先进先出置换算法）

    最简单的页面置换算法是先入先出（FIFO）法。这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。

    FIFO的另一个缺点是，它有一种异常现象，即在增加存储块的情况下，反而使缺页中断率增加了。当然，导致这种异常现象的页面走向实际上是很少见的。

  - LFU（最少使用置换算法）

    在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在之前时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如100 ns，在1 ms时间内可能对某页面连续访问成千上万次，因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间(例如100 ns)右移一次。这样，在最近一段时间使用最少的页面将是∑Ri最小的页。LFU置换算法的页面访问图与LRU置换算法的访问图完全相同；或者说，利用这样一套硬件既可实现LRU算法，又可实现LFU算法。应该指出，LFU算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，访问一次和访问10 000次是等效的。 

## 数据结构

- hashtable和hashmap区别

- python字典的数据结构，hash table的实现过程，一个列表数据怎么快速获取某个值

  在Python中，**字典是通过散列表或说哈希表实现的**。字典也被称为关联数组，还称为哈希数组等。也就是说，字典也是一个数组，但**数组的索引是键经过哈希函数处理后得到的散列值**。哈希函数的目的是使键均匀地分布在数组中，并且可以在内存中以O(1)的时间复杂度进行寻址，从而实现快速查找和修改。

- 关于set，map，哈希表的认知与底层实现（红黑树等具体解释）

- 熟悉常用数据结构(list、set、dict、tuple、string),了解 AVL、RBtree、B/B+树

  - list 是可变的对象，元组 tuple 是不可变的对象！由于 tuple 不可变，所以使用 tuple 可以使代码更安全！

  - 相对于 list 而言，tuple 是不可变的，这使得它可以作为 dict 的 key，或者扔进 set 里，而 list 则不行。

    tuple 放弃了对元素的增删（内存结构设计上变的更精简），换取的是性能上的提升：创建 tuple 比 list 要快，存储空间比 list 占用更小。所以就出现了“能用 tuple 的地方就不用 list”的说法。

    多线程并发的时候，tuple 是不需要加锁的，不用担心安全问题，编写也简单多了。

  - 元组里只有一个元素的时候，逗号（，）非常重要

  - **AVL树**是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

    AVL树本质上还是一棵二叉搜索树，它的特点是：

    1.本身首先是一棵二叉搜索树。

    2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。

    也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。

  - **红黑树**是一种特化的AVL树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目【平均性能非常好】。

    红黑树就是一种二叉平衡搜索树，这两个树不是独立的，所以C++中map、multimap、set、multiset的底层实现机制是二叉平衡搜索树，再具体一点是红黑树。

    - **红黑树性质**
      1. 根节点是黑色，叶节点是不存储数据的黑色空节点
      2. 任何相邻的两个节点不能同时为红色
      3. 任意节点到其可到达的叶节点间包含相同数量的黑色节点

  - 数据库系统普遍采用**B-/+Tree**作为索引结构（例如mysql的InnoDB引擎使用的B+树）

    B树的出现是为了弥合不同的存储级别之间的访问速度上的巨大差异，实现高效的 I/O。平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。但是当数据量非常大，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况。B树是解决这个问题的很好的结构

    **B树**是一种自平衡树数据结构，它维护有序数据并允许以对数时间进行搜索，顺序访问，插入和删除。B树是二叉搜索树的一般化，因为节点可以有两个以上的子节点。与其他自平衡二进制搜索树不同，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于数据库和文件系统。

    B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： 

    - 每个节点最多只有m个子节点。
    - 每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。
    - 如果根不是叶节点，则根至少有两个子节点。
    - 具有*k*个子节点的非叶节点包含*k* -1个键。
    - 所有叶子都出现在同一水平，没有任何信息（高度一致）。

    B+树是应文件系统所需而产生的B树的变形树，那么可能一定会想到，既然有了B树，又出一个B+树，那B+树必然是有很多优点的

     **B+树的特征：**

    - 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；
    - 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；
    - 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；

    **为什么说B+树比B树更适合数据库索引？**

    1）B+树的磁盘读写代价更低

    　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；

    2）B+树查询效率更加稳定

    　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

    3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）

    　　B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；

## 设计模式

- 接触了哪些设计模式 （仔细讲了一下MVC结构 之后说了OpenGL的状态机模式不知道对不对）

  - 单例模式

    单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

    这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

    **注意：**

    - 1、单例类只能有一个实例。
    - 2、单例类必须自己创建自己的唯一实例。
    - 3、单例类必须给所有其他对象提供这一实例。

    **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

    **主要解决：**一个全局使用的类频繁地创建与销毁。

    **何时使用：**当您想控制实例数目，节省系统资源的时候。

    **如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

    **关键代码：**构造函数是私有的。

- 谈谈使用过的几种设计模式，以及优缺点

## 算法

- 快排的时间复杂度，什么时候最坏，什么时候最好

  最好、平均、最坏O(nlogn)  O(nlogn)  O(n^2)

  最差的情况选择的轴枢在数组最左侧或是最右侧

- 熟悉常用的排序算法(冒泡、插入、选择、快排、希尔、堆排、归并、桶、计数)

  - **冒泡排序**

    它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

    这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列）

    冒泡排序算法的原理如下：

    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
    3. 针对所有的元素重复以上的步骤，除了最后一个。
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

    冒泡排序最好的时间复杂度为 `O(n)`，最坏的时间复杂度为`O(n^2)`

  - **插入排序**

    插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

    插入排序最好的时间复杂度为 `O(n)`，最坏的时间复杂度为`O(n^2)`

  - **选择排序**

    选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

    选择排序最好的时间复杂度为 `O(n^2)`，最坏的时间复杂度为`O(n^2)`

  - **快速排序**

    快速排序（Quicksort）是对冒泡排序算法的一种改进。

    - **排序流程**
      1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。 
      2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
      3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
      4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

  - **希尔排序**

    希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。

    希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

    希尔排序是基于插入排序的以下两点性质而提出改进方法的：

    1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
    2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

    算法时间复杂度`O(n^(1.3—2))`

  - **堆排序**

    **堆排序**（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足**堆积的性质**：即子结点的键值或索引总是小于（或者大于）它的父节点。

    在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：

    - 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
    - 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序
    - 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算

  - **归并排序**

    **归并排序**（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

    时间复杂度为`O(nlogn)`

  - **桶排序**

    **桶排序 (Bucket sort)**或所谓的**箱排序**，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间`O(n)`。但桶排序并不是比较排序，他不受到`O(nlogn)`下限的影响。

  - **计数排序**

    计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当`O(k)>O(n*log(n))`的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是`O(n*log(n))`, 如归并排序，堆排序）

## 网络安全及爬虫

- sql注入问怎么防止。爬虫问怎么爬取整个网站，确保所有网页都爬到。爬取需要注意哪些点。网站怎么存储

- DDoS攻击

  分布式拒绝服务（DDoS）攻击是一种恶意企图，通过大量互联网流量压倒目标或其周围的基础架构来破坏目标服务器，服务或网络的正常流量。

  DDoS攻击通过利用多个受损计算机系统作为攻击流量来源来实现有效性。被利用的机器可以包括计算机和其他网络资源，例如物联网设备。从高层次来看，DDoS就像高速公路的交通堵塞，阻止了常规交通到达其所需的目的地。

  DDoS攻击需要攻击者控制在线计算机网络才能进行攻击。计算机和其他计算机（如物联网设备）感染了恶意软件，将每个计算机转变为机器人（或僵尸）。然后，攻击者可以远程控制僵尸程序组，这称为僵尸网络。

  一旦僵尸网络建立，攻击者就可以通过远程控制方法向每个机器人发送更新的指令来指导机器。当受害者的IP地址被僵尸网络作为目标时，每个僵尸程序将通过向目标发送请求来响应，可能导致目标服务器或网络溢出容量，从而导致对正常流量的拒绝服务。

  **带宽DDoS攻击：**攻击者试图耗尽并阻塞受害者的互联网连接带宽

  **容量耗尽DDoS攻击：**攻击者改而专注于向受害者的服务器发送尽可能多的垃圾HTTP请求，以便占用宝贵的服务器CPU和内存，并阻止合法用户使用目标网站

- 如何避免网页被恶意攻击

  1、关闭不必要的端口和服务

  2、安装杀毒软件或者是防火墙来抵御攻击。

  3、定期修改账户密码，尽量设置的复杂些，不要使用弱密码。

  4、日常维护的时候要注意，不建议在服务器上安装过多的软件。

  5、及时修复漏洞，在有官方安全补丁发布时，要及时更新补丁。

  6、设置账户权限，不同的文件夹允许什么账号访问、修改等，同时，重要的文件夹建议增加密码。

  7、建议要定期备份数据，当有发现问题时，可以及时替换成正常的文件。

  8、云漫网络高防CDN可隐藏源服务器ip，抵御大规模的攻击

  **DDOS攻击和CC攻击：**`DDOS`流量攻击主要通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的，它的攻击攻击途径一般都是通过通过向服务器提交大量请求，使服务器超负荷，阻断某一用户访问服务器和某服务与特定系统或个人的通讯。CC主要是用来攻击页面的，CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。简单的来说CC就是模拟多个用户不停地进行访问那些需要大量数据操作，也就是不停占用大量CPU，使服务器永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。

  **DDOS攻击应对措施**

  1. 减少公开暴露：具体措施包括禁止对主机的非开放服务的访问，限制同时打开的 SYN 最大连接数，限制特定 IP 地址的访问，启用防火墙的防 DDoS 的属性
  2. 利用扩展和冗余：采用负载均衡。结合 CDN 系统通过多个节点分散流量，避免流量过度集中，还能做到按需缓存，使系统不易遭受 DDoS 攻击。
  3. 充足的网络带宽保证：网络带宽直接决定了能抗受攻击的能力
  4. 分布式服务拒绝DDOS攻击：分布式资源共享服务器就是指数据和程序可以不位于一个服务器上，而是分散到多个服务器。分布式有利于任务在整个计算机系统上进行分配与优化，克服了传统集中式系统会导致中心主机资源紧张与响应瓶颈的缺陷，分布式数据中心规模越大，越有可能分散 DDoS 攻击的流量，防御攻击也更加容易。
  5. 实时监控系统性能：系统监控能够实时监控系统可用性、API、CDN 以及 DNS 等第三方服务商性能，监控网络节点，清查可能存在的安全隐患，对新出现的漏洞及时进行清理

- https是怎么实现的

  HTTP：（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。（2） 篡改风险（tampering）：第三方可以修改通信内容。（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

  对报文进行加密，互联网加密通信 HTTPS = HTTP + SLL/TLS

- 掌握数字签名原理、了解 https 的安全机制的工作原理

  数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是在使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名是非对称密钥加密技术与数字摘要技术的应用

  HTTPS(全称：Hyper Text Transfer Protocol over SecureSocket Layer)，是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与TCP之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面

  SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

## 前端

- 对前端HTML CSS 和 JS了解多少？熟悉吗？
- 对React和bootstrap了解吗?
- 如何进行http优化？(响应头设置Content-Encoding: gzip)

## 计算机网络/网络编程Socket

- 说一下实现TCP建立连接的过程以及当时进入了什么状态？为什么建立连接只需要3次，断开连接需要4次？为什么断开连接时第二次和第三次要分开，不能合在一起吗？

- 谈一谈http，https

- tcp怎么实现可靠传输，udp可以可靠传输吗？

- stmp，ftp了解吗

- tcp listen backlog

- 输入URL 到页面加载过程

- Cookie 和 Session 的原理分别是什么？

- GET 和 POST 的区别？

- TCP 粘包和粘包分别是什么？

  粘包：在进行数据传输时，发送端一次性连续发送多个数据包，TCP 协议将多个数据包打包成一个 TCP 报文发送出去；拆包：当发送端发送的数据包长度超过一次 TCP 报文所能传输的最大值时，就会将该数据包拆分成多个 TCP 报文分开传输。

- 如何解决粘包和拆包问题？

  1. 设置消息定长
  2. 头部添加消息长度
  3. 消息尾部添加特殊字符进行分割
  4. 将消息分为消息头和消息尾

- 从网页上输一个网址到加载出页面这中间可能发生了什么，详细介绍

- 交换机接收到数据包之后会进行什么操作？

- Keepalived

  Keepalived是Linux下一个轻量级别的高可用解决方案。高可用(High Avalilability,HA)，其实两种不同的含义：广义来讲，是指整个系统的高可用行，狭义的来讲就是之主机的冗余和接管，

  它与HeartBeat RoseHA 实现相同类似的功能，都可以实现服务或者网络的高可用，但是又有差别，HeartBeat是一个专业的、功能完善的高可用软件，它提供了HA 软件所需的基本功能，比如：心跳检测、资源接管，检测集群中的服务，在集群节点转移共享IP地址的所有者等等。HeartBeat功能强大，但是部署和使用相对比较麻烦，

  与HeartBeat相比，Keepalived主要是通过虚拟路由冗余来实现高可用功能，虽然它没有HeartBeat功能强大，但是Keepalived部署和使用非常的简单，所有配置只需要一个配置文件即可以完成，

- 如果接收缓冲区满了，发送端怎么操作，会报错吗

- 发送端发送socket阻塞对发送端接收数据有影响吗

- 计算机网络结构？TCP和UDP区别？熟悉 OSI 七层模型和 TCP/IP 四层体系分层结构

  OSI体系结构：应用层->表示层->会话层【PDU:报文】->传输层【数据段】->网络层【数据包】->数据链路层【数据帧】->物理层【比特】（PDU:协议数据弹单元）

  TCP/IP体系结构：应用层(TELNET, FTP, SMTP, HTTP, DNS, SNMP[管理与监视网络设备])->传输层【进程】->网络层【主机】->网络接口层

  - 物理层：主要设备有网卡，中继器和集线器

  - 数据链路层：互联设备之间传送和识别数据帧

  - 网络层：地址管理和路由选择，ICMP,ARP(通过IP找MAC)

  - 传输层：管理两个节点之间的数据传输，TCP/UDP

    **TCP/UDP的区别**：TCP是面向连接，点对点，传输可靠，有流量控制、用塞控制，提供全双工通信，以字节流的形式传输，传输效率慢，所需资源多，应用在要求通信数据可靠的场合。
    UDP是面向无连接，一对一、一对多、多对一和多对多，传输不可靠，以数据报文段的形式传输，传输效率快，所需资源少，应用在要求通信速度高的场合，首部8个字节。

  - 会话层：通信管理，负责建立和断开通信连接

  - 表示层：负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式

  - 应用层：为特定应用程序提供数据传输服务

- 熟悉 TCP 的三次握手和四次挥手，了解 TCP 的流量控制和拥塞控制

  **TCP三次握手**

  假设 A 为客户端，B 为服务器端。

  1. 首先 B 处于 LISTEN（监听） 状态，等待客户的连接请求。
  2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
  3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
  4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为x+1。
  5. B 收到 A 的确认后，连接建立。

  **三次握手原因**

  第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。
  **TCP四次挥手**

  1. A 发送连接释放报文，FIN=1。
  2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A不能向 B 发送数据。
  3. 当 B 不再需要连接时，发送连接释放报文，FIN=1。
  4. A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间） 后释放连接。
  5. B 收到 A 的确认后释放连接。

  **四次挥手原因**

  客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSEWAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

  *TIME_WAIT*
  客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个由：

  1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
  2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

  **TCP可靠传输**

  TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

  **TCP滑动窗口**

  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

  接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。
  **TCP流量控制**

  流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

  **TCP拥塞控制**

  如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

  TCP 主要通过**四种算法**来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复**。

  1. 慢开始与拥塞避免
     发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …，注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。
  2. 快重传与快恢复
     在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M 和 M ，此时收到 M ，应当发送对 M 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M ，则 M 丢失，立即重传 M 。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。
     注：慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

- 掌握常见网络协议:网桥、ARP、IP、ICMP、TCP、UDP、 DNS、DHCP

  **网桥：**网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的同一网段在数据链路层连接起来，只能连接同构网络(同一网段)，不能连接异构网络（不同网段）。

  **ARP：**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址（MAC地址）的一个TCP/IP协议。

  **IP：**IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网络层协议。设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。IP是整个TCP/IP协议族的核心，也是构成互联网的基础。IP位于TCP/IP模型的网络层(相当于OSI模型的网络层)，它可以向传输层提供各种协议的信息，例如TCP、UDP等；对下可将IP信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。为了能适应异构网络，IP强调适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP不保证分组的交付时限和可靠性，所传送分组有可能出现丢失、重复、延迟或乱序等问题。

  **ICMP：**ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。当路由器在处理一个数据包的过程中发生了意外，可以通过ICMP向数据包的源端报告有关事件。

  **TCP：**传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。

  **UDP：**Internet协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。

  **DNS：**域名系统（英文：Domain Name System，缩写：**DNS**）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。

  **DHCP：**DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。

## 项目

- 说一下一个请求过来到返回response的过程
- 如何实现单点登录
- JWT token是如何进行生成和校验的
- 了解过哪些后端框架？Tornado了解吗?
- 了解过webapp2吗
- Django如何实现csrf攻击保护
- 说说你项目中遇到的困难以及如何解决
- 说说你认为自己最有成就感或最深刻的项目
- 对KAFKA了解吗？用过哪些消息队列？使用过RabbitMQ吗?
- 项目团队几个人？开发多长时间？

## 微服务

- 微服务你了解哪些

- 微服务有什么好处，又有什么弊端

## 版本控制

- 如何从远程仓库拉取分支到本地
  1. 本地初始化环境：`git init`
  2. 与远程仓库建立连接：`git remote add origin xxx.git`
  3. 使用git branch -a 查看本地是否具有dev分支
  4. 把远程分支拉到本地：`git fetch origin dev`（`dev`为远程仓库分支名）
  5. 在本地创建分支dev并切换到该分支：`git checkout -b dev(本地分支名称) origin/dev(远程分支名称)`
  6. 把某个分支上的内容都拉取到本地：`git pull origin dev(远程分支名称)`
- 如何进行版本回退
- 如果是自己管理项目，怎么处理分支、pr、release等

## 深度学习

- SGD与Adam的区别
- Xrange与range
- Isinstance与type区别
- K-M
- 聚类算法，密度
- RNN，LSTM,GRU
- 堆栈，图，编程
- 随机森林
- Bagging 和boosting
- 熟悉 ResNet、Inception、DenseNet、ViT 等模型，了解 SE、CBAM 等注意力机制模块 
- 熟悉 Linux 下 PyTorch 运行环境搭建过程，了解多 GPU 并行训练
- 熟悉 UrbanSound8K、ESC-10/ESC-50 等音频数据集预处理过程
- 熟悉 PyTorch 模型训练流程及模型测试流程
- 了解 CAM、Grad-CAM 等模型可视化方法

## 多进程多线程

- 线程用哪些库，协程怎么实现、原理是什么

  threading

- 死锁的概念

  死锁是指两个或两个以上的进程在执行过程中，由于**竞争资源**或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

  死锁发生的四个必要条件

  1. **互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
  2. **请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
  3. **不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
  4. **环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

  只要打破四个必要条件之一就能有效防止死锁的发生

  1. **打破互斥条件：**改造独占性资源为虚拟资源，大部分资源已无法改造。
  2. **打破不可抢占条件：**当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
  3. **打破占有且申请条件：**采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
  4. **打破循环等待条件：**实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。

  **银行家算法**

  把一个进程需要和已占有资源的情况记录在进程控制中，假定进程控制块PCB其中“状态”有就绪态、等待态和完成态。当进程在处于等待态时，表示系统不能满足该进程当前的资源申请。“资源需求总量”表示进程在整个执行过程中总共要申请的资源量。显然，每个进程的资源需求总量不能超过系统拥有的资源总数， 银行算法进行资源分配可以避免死锁。

  - 死锁预防：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。
  - 死锁避免：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。
  - 死锁检测和解除：（1）先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。（2）然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

- 进程和线程？

  对于操作系统而言，进程是整个现代操作系统的根本，操作系統是以进程为单位执行任务。随着技术发展，在执行一些细小任务，且本身无需分配单独资源时，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间，所以就有了专门的多任务技术被创造出来——线程。 线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。

  进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

  - 进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。
  - 线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。
  - 计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。
  - 进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。
  - 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。

## 其他

- Docker的了解，常用命令，如何暴露端口
- 分布式架构有没有了解

## 简历

### 实习经历

(1)、实习时间:2020 年 10 月---2021 年 8 月

(2)、实习内容:代码实现导线动态增容计算模型，并使用 ECharts 可视化数据; 

(3)、所使用的技术:Python、MySQL、Linux、Socket、JSON、ECharts 

(4)、所做的大概功能模块:

1、使用 socket.socket 创建服务器端和客户端的 TCP 套接字。服务器端:setsockopt 配置服务器端 socket 的 ip 和端口号，bind 绑定服务器端的端口号，listen 设置服务器端连接方式为被动接收，accept 堵塞等待 客户端请求。客户端:connect 连接服务器，send 向服务器端发送数据 ----->Socket

2、接收设备传输的 JSON 格式数据，并对数据进行键值对解析 ----->JSON

3、python 调用 PyMySQL 模块，connect()方法打开 MySQL 数据库连接，并使用 cursor()方法获取操作 游标，进行后续插入、查找等操作 ----->MySQL

4、使用 pyechart 插件，对数据库查询返回的数据调用 render()方法进行图表渲染 -->ECharts 

最终的实现目的:对设备上传的数据设置 TCP 端口进行接收存储，并通过 ECharts 渲染历史数据图表，便于用户观测电力系统实时运行情况，对异常现象进行及时的报警处理; 

(5)、收获:对于一个完整的项目设计有了更加深刻的理解，对于程序的调试定位掌握了更多，让自己更加明白了快速的学习新东西在应用到业务开发上面的重要性。

### 项目简介

**重点在于阐明项目的主要业务，自己做了哪几个模块。碰到了哪些问题，如何解决的。收获了哪些经验和方法论**

- 介绍项目【有没有遇到项目无法解决的问题，最后怎么做的/遇到的挫折，举个例子/在项目中学到了什么东西】，问实现细节，说一下设计思路
- 项目的设计思路，遇到了什么问题，有哪些解决办法。为了解决这些问题，你用了哪些技术栈，为什么要用这些技术栈

1. 基于时域及频域联合注意力机制的声源识别

   (1)、项目简介:该项目实现对设备实时采集的音频进行声源特征提取，并判断声源类型

   (2)、开发时间:2021 年 7 月份，后部署于微信小程序 

   (3)、开发环境:Linux，Python，PyTorch，HTML，CSS，JavaScript

   (4)、项目技术点:音频数据预处理、音频数据扩增、音频时域及频域特征压缩提取、特征融合、模型可

   视化

   (5)、功能简介:在时域及频域两个维度上分别对音频特征进行提取，避免了 SENet 注意力机制模块中特 征压缩阶段所产生的耦合现象，有助于更明确的归纳音频全局特征，减小噪声影响

2. 基于微信小程序云数据库的电力电缆载流量数据查询

   (1)、项目简介:对各地的表格文件上传至云数据库整合，并提供在线数据查询下载功能

   (2)、开发时间:2020 年 12 月份
   (3)、开发环境:HTML，CSS，JavaScript，MySQL 

   (4)、项目技术点:云数据库开发、在线表格生成

   (5)、功能简介:

   a)、云数据库开发实现对数据的在线管理及查询，在声明数据库对象后，在 collection 中填入数据 表名称，在 where 中填入查询条件，查询后返回 json 格式数据

   b)、npm 导入 node-xlsx 库，通过 build 方法建立表格，通过 cloud.uploadFile 上传文件到云存储库 中并返回文件 ID

### 学术成果

1、Gang Liu，Zhifeng Xu，Hui Ma，Yanpeng Hao，Pengyu Wang，**Wenbo Wu**，Yue Xie, Deming Guo. An improved analytical thermal rating method for cables installed in short-conduits[J]. International Journal of Electrical Power & Energy Systems, 2020, 123:106223.
 2、**吴温博**, 金文标. 基于主成分分析的高光谱图像降维[J]. 内蒙古科技与经济, 2018, No.416(22):68-69.

PSNR是最普遍，最广泛使用的评鉴画质的客观量测法，不过许多实验结果都显示，PSNR的分数无法和人眼看到的视觉品质完全一致，有可能PSNR较高者看起来反而比PSNR较低者差。这是因为人眼的视觉对于误差的敏感度并不是绝对的，其感知结果会受到许多因素的影响而产生变化

可以看出*PSNR越高*,图像和原图越接近。

SSIM：计算稍复杂，其值可以较好地反映人眼主观感受。一般取值范围：0-1.值越大，视频质量越好。

---

## 深信服三面

1、介绍自己，说一到两个最主要的工作突破，也可以是比较重要的事情

 2、问竞赛，问科研经历，问[项目]()，有无实习（无）

 3、问其他语言掌握程度

 4、对网络安全和云计算有了解吗（无）

 5、未来考虑在python开发序列之外找工作吗，python工作内容的倾向性

 6、反问（部门岗位工作，code view如何做，具体标准，能不能去想去的部门）

1、自我介绍

面试官好，我是吴温博，来自华南理工大学计算机科学与工程学院，目前正在攻读硕士学位。在校期间，我发表了一篇SCI论文和一篇中文核心论文，两份软著。另外还有一个专利正在受理中。我平时经常参加LeetCode编程竞赛和Kaggle平台大数据竞赛、以及实验室项目的数据平台开发和人工智能在电力应用的相关项目，并在GitHub上维护相关项目代码。在今年上半年我参与了南方电网电科院实习，针对项目传感器数据接收部分进行了优化，从原来的单进程到现在使用多线程方式接受各个传感器的数据，使系统内存在的无法短时间接收多台设备数据的问题得到了有效解决。因为研究生期间使用python比较多，所以对Python开发相关岗位感兴趣。

 2、你知道自己为什么会有三面吗，你觉得你的表现能通过sp吗

 3、为什么选择Python这门语言

1、一起走路的人很多：有很多人和你一起在使用python，你的问题很容易找到答案，你的学习成本和犯错成本是很低的。同时python的社区活跃度很高，很多人无私地贡献了很多开源的包，比如pandas、numpy、django等，你可以站在巨人的肩膀上很快地实现你的目的。

2、这条路很宽：python的应用领域很广，包括但不限于人工智能、数据分析、爬虫、web开发、自动化测试，只要你使用Python，你未来是有很多可能性的。

3、这条路很好走：Python是一种高级编程语言，很多底层的东西都被封装了，开发者无需关心什么内存泄漏、垃圾回收，直接使用即可。你可以一行代码实现一个功能，你用C试试？

接近英语的简单语法；
开发环境简单，能打字就能写代码；
众多的第三方库；
解释执行，不需要编译；
跨平台，方便移植；

`1.验证算法 2.快速开发3.测试运维4.数据分析`

 4、了解[深信服]()吗，为什么选择投递[深信服]()，公司选择的倾向性

专注于企业级网络安全、云计算及IT基础架构的产品和服务提供商，业务覆盖全球50多个国家和地区，CCIA中国网络安全竞争力榜首

公司所在行业是代表了未来发展趋势的新兴行业，看好将来的发展前景；是公司在某个方面的实力是你看重的

我很了解我应聘的职位（熟悉，喜欢

倾向于有更好的发展前进和发展动力的企业

 这些大概5分钟

 5、反问（是否需要提前实习，试用期，新人培养机制，职级架构，等等等等，面试官小改改很会聊天，见识很广，谈吐也非常得体，一次hr面让我打开了眼界）



1. 自我介绍
2. 讲一讲自己觉得收获最大的一个[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)(个人博客)
3. 聊网络安全
4. 说说[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)的发展和对[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)未来的展望
5. 说说 对 "一个技术型管理层" 的理解
6. 对微[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)，微服务，大[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)的理解。

1. 介绍[深信服](https://www.nowcoder.com/jump/super-jump/word?word=深信服)
2. 介绍部门业务、技术栈
3. 介绍团队

1. 自我介绍 

  2.问问兴趣爱好啥的 

平时晚上喜欢去湖边跑步，以及参与编程竞赛与大数据竞赛。有时候也会去做一些提升工作效率的小应用

  3.你在大学一天的作息怎样 

  4.你从懂事开始遇到最大的困难是什么 

  5.从你的某个[项目]()某个点说起，说说你是怎么看待的，并且你是怎么相对别人有优势的 

  6.你对[深信服]()的了解如何 

  7.网上对[深信服]()加班有点诟病，你是怎么看待的？

（我觉得加班没有任何问题，年轻人就应该奋斗！） 

  8.你目前收到其他offer了吗？具体是什么工作的 

没有

  9.你对薪资的要求是怎样的 

20-25W

这个公司给的薪资算行业里中等偏上的水平，涨薪机制也蛮明确的，管理方式上也比较人性化，只要认真努力，在工作中能有成绩，后期的涨薪肯定也不是大问题。不少公司的薪资都是入职即高峰，后期涨薪非常困难，他们这一点还是做的蛮好的，每年都会有调薪的机会。

问工作地点意向（这应该是个大坑）

聊学校经历

聊研究生研究方向

聊SCI论文

聊实习经历，现在公司的上下班时间，工作方式

聊学习方式

聊生活，作息时间

现在手里的offer薪资

三面线下hr面（10.11）： 

  自我介绍，家庭情况，offer情况，周围人怎么看你，你自己认为你是个什么样的人，你自己认为呢？ 

  面试官比较忙，中间接了两个电话。 

  回来直接给我说给你说一下你的岗位和薪资吧，工作情况，加班情况，然后还有校招后续安排。

有没有其它公司的 offer，我说有[平安科技]()的实习 offer，是`Java`的，不太想去。（[平安科技]()这公司我挺喜欢的，但是我投的上海只有北京了，也就是因为这样我才没第一时间去） 

就和别的公司 HR 面差不多这里就不细说了

**sp面**

python垃圾回收 

 python分代回收中的数据结构 

 python中的回收对象怎么快速确定内存位置 

 python回收内存溢出情况，怎么检查以及处理 

 什么是python元类 

 python库？ 

 python进程/线程/协程 

 python协程怎么使用 

 python死锁怎么处理？怎么避免 

 mysql加载机制？ 

 mysql innodb内部数据的保存结构 

 B树/B+树的区别 

 网络编程连接握手阶段 半连接队列/全连接队列 

 TCP三次握手 

 看了哪些开源库？加入了什么开源社区？ 

### pytorch

segmentfault和stack overflow



## 备份的必要性

再生产环境中，为了防止硬件故障、软件故障、自然灾害、误操作等各种原因导致的数据库数据丢失后能恢复到事故之前的状态，我们需要对数据库进行备份和恢复操作。数据库的备份和恢复是非常重要的工作，数据的备份不是最终目的，数据的恢复才是。

**备份时应该注意的事项有哪些呢**

1.最多能容忍多少数据丢失

2.恢复数据需要在多长时间内完成

3.需要恢复那些数据

4.定期测试备份的可用性并提高恢复操作的效率

5.备份时的服务器负载

6.锁定资源的时长

## 备份的类型有哪些呢

### a.按照备份的数据集的范围分类：

完全备份：整个数据集；

部分备份：数据集的一部分，比如部分表；

### b.按照数据的变化分类：

完全备份：将整个范围备份；

增量备份：仅备份自上一次完全备份或增量备份以来变量的那部数据；

差异备份：仅备份自上一次完全备份以来变量的那部数据；

### c.按照操作对象分类：

物理备份：直接从磁盘复制数据文件进行备份；

逻辑备份：从数据库导出数据另存在一个或多个文件中，将数据转为具体的SQL语句；

### d.按照数据服务备份时的运行状态分类：

热备：读写操作均可进行的状态下所做的备份；

温备：可读但不可写状态下进行的备份；

冷备：读写操作均不可进行的状态下所做的备份；

## 备份的策略

备份策略一般都是全量+差异+binlogs或者全量+增量+binlogs。需要注意到的是，如果需要更完整的备份数据，还需要依靠binlogs（二进制日志）。binlogs是MySQL中最重要的日志之一，它记录了所有的DDL和DML(除了数据查询语句)语句，以事件形式记录。这里强烈建议在生产环境中，将数据与二进制日志分开存放并对二进制日志也做备份。

## MySQL备份工具　

1.mysqldump：mysql服务自带的备份工具。mysqldump是一个逻辑备份工具，它的本质是将数据库转为可执行SQL脚本。可以用来做完全备份和部分备份，支持InnoDB存储引擎的热备功能，MyISAM存储引擎的温备功能。

2.系统自带的cp/tar工具：这是一种物理备份，这种备份的原理是基于快照实现的，快照（请求一个全局锁），之后立即释放锁，达到几乎热备的效果。需要注意的是不能仅仅只备份数据，要同时备份事务日志，并且要求数据和日志在同一逻辑卷。

\1. **mysqldump：** 最早，也是最成熟的逻辑备份工具，是 MySQL 原生的用来备份整个数据库实例、单个数据库、单张表的逻辑备份工具， 上手简单，学习成本几乎为 0。备份简单，恢复也简单。

比如导出单个数据库 ytt: mysqldump ytt > /tmp/ytt.sql；

恢复也非常简单：mysql < /tmp/ytt.sql

缺点是备份速度慢。在整个备份过程中，是单线程运行；备份出来的数据集要恢复的话同样也是单线程运行，恢复速度也慢。除非对同一时刻的所有表单独备份出来，自己写额外脚本进行多线程恢复。



## 大量数据处理mysql

做多个数据表（日期、散列）进行查询

流量倾斜（设计相关，如果有的数据访问比较旺盛，秒杀订单）



作者：西召
链接：https://zhuanlan.zhihu.com/p/59056833
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## **InnoDB**

InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。

InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

-  更新密集的表。   InnoDB存储引擎特别适合处理多重并发的更新请求。
   
-  事务。   InnoDB存储引擎是支持事务的标准MySQL存储引擎。
   
-  自动灾难恢复。   与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
   
-  外键约束。   MySQL支持外键的存储引擎只有InnoDB。
   
-  支持自动增加列AUTO_INCREMENT属性。
   
-  从5.7开始innodb存储引擎成为默认的存储引擎。

一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

## **MyISAM**

MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器。

每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。

例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：

- tb_demo.frm，存储表定义。 
- tb_demo.MYD，存储数据。
- tb_demo.MYI，存储索引。

MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：

 \1. 选择密集型的表。   MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 

\2. 插入密集型的表。   MyISAM的并发插入特性允许同时选择和插入数据。

由此看来，MyISAM存储引擎很适合管理服务器日志数据。

