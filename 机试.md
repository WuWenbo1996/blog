# 机考流程

- 机考时间：2小时
- 机考方式：题目三道，总分600。**三道题分别是100分、200分、300分**。可使用任意语言进行编程
- 机考知识点：
  1. 基础准备
     - 输入的读取解析和格式输出
     - 基础类型(2进制、10进制、16进制)
  2. 基础数据结构
     - 字符串操作
     - 线性表
     - 队列
     - 栈
     - 链表
     - 哈希表
  3. 高级数据结构
     - 二叉查找树，平衡树
     - 堆，二叉堆
     - 图论，无向图，有向图等基本知识
  4. 常用算法及思想
     - 排序算法（快排、插入、堆排序等）
     - 迭代、递归思想（二分查找，归并排序等）
     - 搜索算法（DFS、BFS）
     - 贪心算法
     - 动态规划

# 笔试模式

**ACM模式与核心代码模式，一般都是ACM模式**

核心代码模式，输入已经给定，只要写好核心代码部分，return结果就可以了

```java
class Solution {
public:
    int getDays(vector<int>& work, vector<int>& gym) {
        // 处理逻辑
    }
};
```

ACM模式需要自己处理输入，核心代码部分，以及输出

```python
while True:
	try:
        # 如果为数字
		a = int(input())
        # 如果为字符串
        b = input()
        # 如果为数组
        c = list(map(int, input.split(' '))
        
        # 输出为数字
        print(a)
        # 输出为间隔的数组
        print(" ".join(c))
	except:
		break
```

# 小技巧

## 字典排序

```python
dict_num = {1:3,4:5,2:3}
dict_num = sorted(dict_num.items(), key=lambda x:x[0], reverse = True)
print(dict_num) #[(4, 5), (2, 3), (1, 3)]
```

## 其他进制转10进制

```python
#下面是16进制得‘0xA’转10进制，很显然结果是10
int('0xA', 16)
```

## 10进制转2进制

```python
# 十进制的10转化为2进制
bin(10) # 0b1010
```

## 四舍五入

```python
num = float(input())
print(int(num+0.5))
```

# 数学

## 最小公倍数

```python
# 最小公倍数 = 两数之积除以最大公约数
def gcd(a, b):
    """Return greatest common divisor using Euclid's Algorithm."""
    while b:
        a, b = b, a % b
    return a
def lcm(a, b):
    """Return lowest common multiple."""
    return a * b // gcd(a, b)

while True:
    try:
        a,b=map(int,input().split())
        print(lcm(a,b))
    except:
        break
```

# 数组

## 二分查找

当数组**有序**，且数组中**无重复元素**，可以考虑使用二分查找。重点在于对区间的认知。`l <= r`说明`l == r`是有意义的，如果`nums[mid] != target`，那么`mid`一定不符合要求

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)-1

        while l <= r:
            mid = (l + r) // 2

            if nums[mid] < target:
                l = mid + 1
            elif nums[mid] > target:
                r = mid - 1
            else:
                return mid
        
        return -1
```

## 移除元素

使用`快慢指针法`，**通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作**

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow, fast = 0, 0

        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            
            fast += 1
        
        return slow
```

## 有序数组的平方

使用`双指针法`，在数组开始和结尾处分别放指针，然后对左右两边的数值进行比较

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        i,j,k = 0,n - 1,n - 1
        ans = [-1] * n
        while i <= j:
            lm = nums[i] ** 2
            rm = nums[j] ** 2
            if lm > rm:
                ans[k] = lm
                i += 1
            else:
                ans[k] = rm
                j -= 1
            k -= 1
        return ans
```

## 长度最小的子数组

使用`滑动窗口`，**不断的调节子序列的起始位置和终止位置，从而得到我们想要的结果**

- 窗口内是什么
- 如何移动窗口的起始位置
- 如何移动窗口的结束位置

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        # 定义一个无限大的数
        res = float("inf")
        Sum = 0
        index = 0
        for i in range(len(nums)):
            Sum += nums[i]
            while Sum >= s:
                res = min(res, i-index+1)
                Sum -= nums[index]
                index += 1
        return 0 if res==float("inf") else res
```

## 螺旋矩阵

**本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。**一定要坚持**循环不变量原则**。

```python
class Solution:

    def generateMatrix(self, n: int) -> List[List[int]]:
        # 初始化要填充的正方形
        matrix = [[0] * n for _ in range(n)]

        left, right, up, down = 0, n - 1, 0, n - 1
        number = 1  # 要填充的数字

        # 注意范围
        while left < right and up < down:

            # 从左到右填充上边
            for x in range(left, right):
                matrix[up][x] = number
                number += 1

            # 从上到下填充右边
            for y in range(up, down):
                matrix[y][right] = number
                number += 1

            # 从右到左填充下边
            for x in range(right, left, -1):
                matrix[down][x] = number
                number += 1

            # 从下到上填充左边
            for y in range(down, up, -1):
                matrix[y][left] = number
                number += 1

            # 缩小要填充的范围
            left += 1
            right -= 1
            up += 1
            down -= 1

        # 如果阶数为奇数，额外填充一次中心
        if n % 2:
            matrix[n // 2][n // 2] = number

        return matrix
```

# 链表

## 移除链表元素

设置一个虚拟头节点进行删除操作

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy_head = ListNode(next=head) #添加一个虚拟节点
        cur = dummy_head
        while(cur.next!=None):
            if(cur.next.val == val):
                cur.next = cur.next.next #删除cur.next节点
            else:
                cur = cur.next
        return dummy_head.next
```

## 设计链表

设置一个虚拟头节点进行操作

```python
# 单链表
class Node:
    
    def __init__(self, val):
        self.val = val
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head = Node(0)  # 虚拟头部节点
        self._count = 0  # 添加的节点数

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._head
            for _ in range(index + 1):
                node = node.next
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self._count, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return

        # 计数累加
        self._count += 1

        add_node = Node(val)
        prev_node, current_node = None, self._head
        for _ in range(index + 1):
            prev_node, current_node = current_node, current_node.next
        else:
            prev_node.next, add_node.next = add_node, current_node

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            # 计数-1
            self._count -= 1
            prev_node, current_node = None, self._head
            for _ in range(index + 1):
                prev_node, current_node = current_node, current_node.next
            else:
                prev_node.next, current_node.next = current_node.next, None


# 双链表
# 相对于单链表, Node新增了prev属性
class Node:
    
    def __init__(self, val):
        self.val = val
        self.prev = None
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head, self._tail = Node(0), Node(0)  # 虚拟节点
        self._head.next, self._tail.prev = self._tail, self._head
        self._count = 0  # 添加的节点数

    def _get_node(self, index: int) -> Node:
        # 当index小于_count//2时, 使用_head查找更快, 反之_tail更快
        if index >= self._count // 2:
            # 使用prev往前找
            node = self._tail
            for _ in range(self._count - index):
                node = node.prev
        else:
            # 使用next往后找
            node = self._head   
            for _ in range(index + 1):
                node = node.next
        return node

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self._update(self._head, self._head.next, val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self._update(self._tail.prev, self._tail, val)

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        elif index > self._count:
            return
        node = self._get_node(index)
        self._update(node.prev, node, val)

    def _update(self, prev: Node, next: Node, val: int) -> None:
        """
            更新节点
            :param prev: 相对于更新的前一个节点
            :param next: 相对于更新的后一个节点
            :param val:  要添加的节点值
        """
        # 计数累加
        self._count += 1
        node = Node(val)
        prev.next, next.prev = node, node
        node.prev, node.next = prev, next

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if 0 <= index < self._count:
            node = self._get_node(index)
            # 计数-1
            self._count -= 1
            node.prev.next, node.next.prev = node.next, node.prev
```

## 反转链表

设置`pre`和`cur`两个指针，`pre`初始指向`None`，`cur`初始指向第一个元素。之后不断将这两个指针向后移动（中间需要使用`tmp`保存`cur.next`），直到`cur`指针指向None

```python
# 迭代法
# 双指针
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur.next = pre #反转
            #更新pre、cur指针
            pre = cur
            cur = temp
        return pre
    
# 递归法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        def reverse(pre,cur):
            # 如果cur为None，则已经到达链表结尾，return结果
            if not cur:
                return pre
            
            # 移动指针，并且改变指针的指向
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None, head)
```

## 两两交换链表中的节点

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        res = ListNode(next=head)
        pre = res
        
        # 必须有pre的下一个和下下个才能交换，否则说明已经交换结束了
        while pre.next and pre.next.next:
            cur = pre.next
            post = pre.next.next
            
            # pre，cur，post对应最左，中间的，最右边的节点
            cur.next = post.next
            post.next = cur
            pre.next = post

            pre = pre.next.next
        return res.next
```

## 删除链表的倒数第N个节点

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

1. 定义fast指针和slow指针，初始值为虚拟头结点
2. fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）
3. fast和slow同时移动，之道fast指向末尾
4. 删除slow指向的下一个节点

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        head_dummy = ListNode(next=head)

        slow, fast = head_dummy, head_dummy
        while(n!=0): #fast先往前走n步
            fast = fast.next
            n -= 1
        while(fast.next!=None):
            slow = slow.next
            fast = fast.next
        #fast 走到结尾后，slow的下一个节点为倒数第N个节点
        slow.next = slow.next.next #删除
        return head_dummy
```

## 链表相交

# 哈希表

哈希表是根据**关键码的值**而直接进行访问的数据结构。

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

## 哈希函数

通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下表的位置 --> **哈希碰撞**

## 哈希碰撞

一般哈希碰撞有两种解决方法， 拉链法和线性探测法

### 拉链法

发生冲突的元素都被存储在链表中。其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。

## 常见的三种哈希结构

- 数组
- set （集合）
- map(映射)

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(logn)  | O(logn)  |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(logn)  | O(logn)  |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

## 有效的字母异位词

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in range(len(s)):
            #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[ord(s[i]) - ord("a")] += 1
        print(record)
        for i in range(len(t)):
            record[ord(t[i]) - ord("a")] -= 1
        for i in range(26):
            if record[i] != 0:
                #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return False
        return True

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)

        for x in s:
            s_dict[x] += 1
        
        for x in t:
            t_dict[x] += 1

        return s_dict == t_dict
```

## 两个数组的交集

**输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序**

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))    # 两个数组先变成集合，求交集后还原为数组
```

## 快乐数

题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        def calculate_happy(num):
            sum_ = 0
            
            # 从个位开始依次取，平方求和
            while num:
                sum_ += (num % 10) ** 2
                num = num // 10
            return sum_

        # 记录中间结果
        record = set()

        while True:
            n = calculate_happy(n)
            if n == 1:
                return True
            
            # 如果中间结果重复出现，说明陷入死循环了，该数不是快乐数
            if n in record:
                return False
            else:
                record.add(n)
```

## 两数之和

使用数组和set来做哈希法的局限

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下表位置，因为要返回x 和 y的下表。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下表。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        records = dict()

        # 用枚举更方便，就不需要通过索引再去取当前位置的值
        for idx, val in enumerate(nums):
            if target - val not in records:
                records[val] = idx
            else:
                return [records[target - val], idx] # 如果存在就返回字典记录索引和当前索引
```

## 四数相加II

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```python
class Solution(object):
    def fourSumCount(self, nums1, nums2, nums3, nums4):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type nums3: List[int]
        :type nums4: List[int]
        :rtype: int
        """
        # use a dict to store the elements in nums1 and nums2 and their sum
        hashmap = dict()
        for n1 in nums1:
            for n2 in nums2:
                if n1 + n2 in hashmap:
                    hashmap[n1+n2] += 1
                else:
                    hashmap[n1+n2] = 1
        
        # if the -(a+b) exists in nums3 and nums4, we shall add the count
        count = 0
        for n3 in nums3:
            for n4 in nums4:
                key = - n3 - n4
                if key in hashmap:
                    count += hashmap[key]
        return count
 
# 下面这个写法更为简洁，但是表达的是同样的算法
# class Solution:
#     def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
#         from collections import defaultdict

#         hashmap = defaultdict(int)

#         for x1 in nums1:
#             for x2 in nums2:
#                 hashmap[x1+x2] += 1
        
#         count=0
#         for x3 in nums3:
#             for x4 in nums4:
#                 key = 0 - x3 - x4
#                 value = hashmap[key]  # 若差值(key)不存在，则value被赋值0
#                 count += value                
#         return count

```

# 字符串

## 反转字符串

使用双指针处理，交换左右指针位置的数值即可，交换后指针移位

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低
        # 推荐该写法，更加通俗易懂
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

## 反转字符串II

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        """
        1. 使用range(start, end, step)来确定需要调换的初始位置
        2. 对于字符串s = 'abc'，如果使用s[0:999] ===> 'abc'。字符串末尾如果超过最大长度，则会返回至字符串最后一个值，这个特性可以避免一些边界条件的处理。
        3. 用切片整体替换，而不是一个个替换.
        """
        def reverse_substring(text):
            left, right = 0, len(text) - 1
            while left < right:
                text[left], text[right] = text[right], text[left]
                left += 1
                right -= 1
            return text
        
        res = list(s)

        for cur in range(0, len(s), 2 * k):
            res[cur: cur + k] = reverse_substring(res[cur: cur + k])
        
        return ''.join(res)
```

## 替换空格

首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：

i指向新长度的末尾，j指向旧长度的末尾。

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

**这么做有两个好处：**

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        counter = s.count(' ')
        
        res = list(s)
        # 每碰到一个空格就多拓展两个格子，1 + 2 = 3个位置存’%20‘
        res.extend([' '] * counter * 2)
        
        # 原始字符串的末尾，拓展后的末尾
        left, right = len(s) - 1, len(res) - 1
        
        while left >= 0:
            if res[left] != ' ':
                res[right] = res[left]
                right -= 1
            else:
                # [right - 2, right), 左闭右开
                res[right - 2: right + 1] = '%20'
                right -= 3
            left -= 1
        return ''.join(res)
```

## 反转字符串里的单词

所以这里我还是提高一下本题的难度：**不要使用辅助空间，空间复杂度要求为O(1)。**

不能使用辅助空间之后，那么只能在原字符串上下功夫了。

想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒叙了，那么再把单词反转一下，单词不就正过来了。

所以解题思路如下：

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

举个例子，源字符串为："the sky is blue "

- 移除多余空格 : "the sky is blue"
- 字符串反转："eulb si yks eht"
- 单词反转："blue is sky the"

这样我们就完成了翻转字符串里的单词。

```python
class Solution:
  		#1.去除多余的空格
        def trim_spaces(self,s):     
            n=len(s)
            left=0
            right=n-1
        
            while left<=right and s[left]==' ':       #去除开头的空格
                left+=1
            while left<=right and s[right]==' ':        #去除结尾的空格
                right=right-1
            tmp=[]
            while left<=right:         #去除单词中间多余的空格
                if s[left]!=' ':
                    tmp.append(s[left])
                elif tmp[-1]!=' ':   #当前位置是空格，但是相邻的上一个位置不是空格，则该空格是合理的
                    tmp.append(s[left])
                left+=1
            return tmp
        
		#2.翻转字符数组
        def reverse_string(self,nums,left,right):
            while left<right:
                nums[left], nums[right]=nums[right],nums[left]
                left+=1
                right-=1
            return None
        
		#3.翻转每个单词
        def reverse_each_word(self, nums):
            start=0
            end=0
            n=len(nums)
            while start<n:
                while end<n and nums[end]!=' ':
                    end+=1
                self.reverse_string(nums,start,end-1)
                start=end+1
                end+=1
            return None

		#4.翻转字符串里的单词
        def reverseWords(self, s): #测试用例："the sky is blue"
        	#输出：['t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'
            l = self.trim_spaces(s)
            #输出：['e', 'u', 'l', 'b', ' ', 's', 'i', ' ', 'y', 'k', 's', ' ', 'e', 'h', 't']
            self.reverse_string(l,  0, len(l) - 1)   
            #输出：['b', 'l', 'u', 'e', ' ', 'i', 's', ' ', 's', 'k', 'y', ' ', 't', 'h', 'e']
            self.reverse_each_word(l)               
            #输出：blue is sky the
            return ''.join(l)                                 
```

## 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

```python
# 方法一：可以使用切片方法
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[0:n]
        
# 方法二：也可以使用上文描述的方法，有些面试中不允许使用切片，那就使用上文作者提到的方法
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        s = list(s)
        s[0:n] = list(reversed(s[0:n]))
        s[n:] = list(reversed(s[n:]))
        s.reverse()
        
        return "".join(s)
```

## 实现strStr()



## 重复的子字符串

**KMP算法**解决字符串匹配的问题，相比于直接使用暴力解法【O(m x n)】，时间复杂度小很多。

**前缀表**用于找到之前已经匹配过的内容，找到**最长相等前后缀 **。

```
例如模式串aabaaf
a  ->  0
aa ->  1	前缀a与后缀a匹配
aab -> 0	
aaba -> 1	前缀a与后缀a匹配
aabaa -> 2	前缀aa与后缀aa匹配
aabaaf	-> 0 

如果在f处发生不匹配，则看f的前一位的前缀表值为2
因此跳到第2位即b，继续开始匹配
```

**求前缀表**

1. 初始化：首先设置`j=0`(前缀末尾)，`next[0]=0`

2. 循环更新`next`数组（`for i in range(len(s))`）

   - 前后缀不相同

     如果模式串中的`i`和`j`位置处的数值不相等，则`j`持续回退，直到`s[i]==s[j]`或者已经回退到初始位置

     ```python
     while j > 0 and s[i] != s[j]:	
     	j = next[j-1]
     ```

   - 前后缀相同

     如果数值相等，则将`j`向后移动1位

     ```python
     if s[i] == s[j]:
     	j++
     ```

   - 更新`next`数组

     ```python
     next[i] = j
     ```

     



# 栈与队列

**栈与队列的应用场景**：**栈其实就是递归的一种是实现结构**，前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

# 二叉树

- **满二叉树**：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树

- **完全二叉树**：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点

- **二叉搜索树**：**二叉搜索树是一个有序树**。

  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉排序树

- **平衡二叉搜索树**：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

  **C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表

- **二叉树的存储方式**

  **二叉树可以链式存储，也可以顺序存储**

  链式存储使用指针，顺序存储使用数组【顺序存储的元素在内存是连续分布的，链式存储把分布在散落在各个地址的节点串联一起】

  **顺序存储遍历二叉树**：**如果父节点的数组下表是i，那么它的左孩子就是i \* 2 + 1，右孩子就是 i \* 2 + 2**【从下标0开始】

## 二叉树遍历

- **二叉树的遍历方式**

  深度优先遍历【前序遍历(中左右)、中序遍历(左中右)、后序遍历(左右中)】和广度优先遍历【层序遍历】

  深度优先遍历分为**递归遍历**和**迭代遍历**，优先掌握相对简单的递归遍历
  
  **这里前中后，其实指的就是中间节点的遍历顺序**

```python
# 节点定义
class TreeNode: 
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

- **递归三要素**

  1. **确定递归函数的参数和返回值：**确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型
  2. **确定终止条件**
  3. **确定单层递归的逻辑**

  ```python
  # 前序遍历-递归-LC144_二叉树的前序遍历
  class Solution:
      def preorderTraversal(self, root: TreeNode) -> List[int]:
          # 保存结果
          result = []
          
          def traversal(root: TreeNode):
              if root == None:
                  return
              result.append(root.val) # 前序
              traversal(root.left)    # 左
              traversal(root.right)   # 右
  
          traversal(root)
          return result
  
  # 中序遍历-递归-LC94_二叉树的中序遍历
  class Solution:
      def inorderTraversal(self, root: TreeNode) -> List[int]:
          result = []
  
          def traversal(root: TreeNode):
              if root == None:
                  return
              traversal(root.left)    # 左
              result.append(root.val) # 中序
              traversal(root.right)   # 右
  
          traversal(root)
          return result
  
  # 后序遍历-递归-LC145_二叉树的后序遍历
  class Solution:
      def postorderTraversal(self, root: TreeNode) -> List[int]:
          result = []
  
          def traversal(root: TreeNode):
              if root == None:
                  return
              traversal(root.left)    # 左
              traversal(root.right)   # 右
              result.append(root.val) # 后序
  
          traversal(root)
          return result
      
  # 迭代
  # 前序遍历-迭代-LC144_二叉树的前序遍历
  class Solution:
      def preorderTraversal(self, root: TreeNode) -> List[int]:
          # 根结点为空则返回空列表
          if not root:
              return []
          stack = [root]
          result = []
          while stack:
              node = stack.pop()
              # 中结点先处理
              result.append(node.val)
              # 右孩子先入栈
              if node.right:
                  stack.append(node.right)
              # 左孩子后入栈
              if node.left:
                  stack.append(node.left)
          return result
          
  # 中序遍历-迭代-LC94_二叉树的中序遍历
  class Solution:
      def inorderTraversal(self, root: TreeNode) -> List[int]:
          if not root:
              return []
          stack = []  # 不能提前将root结点加入stack中
          result = []
          cur = root
          while cur or stack:
              # 先迭代访问最底层的左子树结点
              if cur:     
                  stack.append(cur)
                  cur = cur.left		
              # 到达最左结点后处理栈顶结点    
              else:		
                  cur = stack.pop()
                  result.append(cur.val)
                  # 取栈顶元素右结点
                  cur = cur.right	
          return result
          
  # 后序遍历-迭代-LC145_二叉树的后序遍历
  class Solution:
      def postorderTraversal(self, root: TreeNode) -> List[int]:
          if not root:
              return []
          stack = [root]
          result = []
          while stack:
              node = stack.pop()
              # 中结点先处理
              result.append(node.val)
              # 左孩子先入栈
              if node.left:
                  stack.append(node.left)
              # 右孩子后入栈
              if node.right:
                  stack.append(node.right)
          # 将最终的数组翻转
          return result[::-1]
  ```

- **因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！**，**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了

- **层序遍历**

  需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

  ```python
  class Solution:
      """二叉树层序遍历迭代解法"""
  
      def levelOrder(self, root: TreeNode) -> List[List[int]]:
          results = []
          if not root:
              return results
          
          from collections import deque
          que = deque([root])
          
          while que:
              size = len(que)
              result = []
              for _ in range(size):
                  cur = que.popleft()
                  result.append(cur.val)
                  if cur.left:
                      que.append(cur.left)
                  if cur.right:
                      que.append(cur.right)
              results.append(result)
  
          return results
          
          
   # 递归法【推荐】
  class Solution:
      def levelOrder(self, root: TreeNode) -> List[List[int]]:
          res = []
          def helper(root, depth):
              if not root: return 
              if len(res) == depth: res.append([]) # start the current depth
              res[depth].append(root.val) # fulfil the current depth
              if  root.left: helper(root.left, depth + 1) # process child nodes for the next depth
              if  root.right: helper(root.right, depth + 1)
          helper(root, 0)
          return res
  ```

## 翻转二叉树

遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

```python
# 递归法：前序遍历
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left #中
        self.invertTree(root.left) #左
        self.invertTree(root.right) #右
        return root

# 迭代法：前序遍历
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        st = []
        st.append(root)
        while st:
            node = st.pop()
            node.left, node.right = node.right, node.left #中
            if node.right:
                st.append(node.right) #右
            if node.left:
                st.append(node.left) #左
        return root
    
# 层序遍历
import collections
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        queue = collections.deque() #使用deque()
        if root:
            queue.append(root)
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                node.left, node.right = node.right, node.left #节点处理
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

## 对称二叉树

给定一个二叉树，检查它是否镜像对称

**首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

**递归三部曲**

1. **确定递归函数的参数和返回值：**因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

2. **确定终止条件：**要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

   节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

   - 左节点为空，右节点不为空，不对称，return false
   - 左不为空，右为空，不对称 return false
   - 左右都为空，对称，返回true

   此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

   - 左右都不为空，比较节点数值，不相同就return false

   此时左右节点不为空，且数值也不相同的情况我们也处理了。

3. **确定单层递归的逻辑：**

   此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

   - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
   - 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
   - 如果左右都对称就返回true ，有一侧不对称就返回false 。

```python
# 递归法
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        return self.compare(root.left, root.right)
        
    def compare(self, left, right):
        #首先排除空节点的情况
        if left == None and right != None: return False
        elif left != None and right == None: return False
        elif left == None and right == None: return True
        #排除了空节点，再排除数值不相同的情况
        elif left.val != right.val: return False
        
        #此时就是：左右节点都不为空，且数值相同的情况
        #此时才做递归，做下一层的判断
        outside = self.compare(left.left, right.right) #左子树：左、 右子树：右
        inside = self.compare(left.right, right.left) #左子树：右、 右子树：左
        isSame = outside and inside #左子树：中、 右子树：中 （逻辑处理）
        return isSame
        
# 迭代法： 使用队列
import collections
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        queue = collections.deque()
        queue.append(root.left) #将左子树头结点加入队列
        queue.append(root.right) #将右子树头结点加入队列
        while queue: #接下来就要判断这这两个树是否相互翻转
            leftNode = queue.popleft()
            rightNode = queue.popleft()
            if not leftNode and not rightNode: #左节点为空、右节点为空，此时说明是对称的
                continue
            
            #左右一个节点不为空，或者都不为空但数值不相同，返回false
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            queue.append(leftNode.left) #加入左节点左孩子
            queue.append(rightNode.right) #加入右节点右孩子
            queue.append(leftNode.right) #加入左节点右孩子
            queue.append(rightNode.left) #加入右节点左孩子
        return True
        
# 迭代法：使用栈
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        st = [] #这里改成了栈
        st.append(root.left)
        st.append(root.right)
        while st:
            leftNode = st.pop()
            rightNode = st.pop()
            if not leftNode and not rightNode:
                continue
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            st.append(leftNode.left)
            st.append(rightNode.right)
            st.append(leftNode.right)
            st.append(rightNode.left)
        return True
```

## 二叉树的最大深度

可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

```python
# 二叉树的深度
# 递归法
class solution:
    def maxdepth(self, root: treenode) -> int:
        return self.getdepth(root)
        
    def getdepth(self, node):
        if not node:
            return 0
        leftdepth = self.getdepth(node.left) #左
        rightdepth = self.getdepth(node.right) #右
        depth = 1 + max(leftdepth, rightdepth) #中
        return depth
    
# 迭代法
import collections
class solution:
    def maxdepth(self, root: treenode) -> int:
        if not root:
            return 0
        depth = 0 #记录深度
        queue = collections.deque()
        queue.append(root)
        while queue:
            size = len(queue)
            depth += 1
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return depth
 
# N叉树
class solution:
    def maxdepth(self, root: 'node') -> int:
        if not root:
            return 0
        depth = 0
        for i in range(len(root.children)):
            depth = max(depth, self.maxdepth(root.children[i]))
        return depth + 1
```

## 二叉树的最小深度

**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**注意是**叶子节点**。

**求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。**

```python
# 递归法
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # 获得左子树的最小高度
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # 获得右子树的最小高度
        return min_depth + 1
 
# 迭代法
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        que = deque()
        que.append(root)
        res = 1

        while que:
            for _ in range(len(que)):
                node = que.popleft()
                # 当左右孩子都为空的时候，说明是最低点的一层了，退出
                if not node.left and not node.right:
                    return res
                if node.left is not None:
                    que.append(node.left)
                if node.right is not None:
                    que.append(node.right)
            res += 1
        return res
```

## 完全二叉树的节点个数

可以按照普通二叉树方法遍历计算节点个数

```python
# 普通二叉树处理
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        return self.getNodesNum(root)
        
    def getNodesNum(self, cur):
        if not cur:
            return 0
        leftNum = self.getNodesNum(cur.left) #左
        rightNum = self.getNodesNum(cur.right) #右
        treeNum = leftNum + rightNum + 1 #中
        return treeNum
 
import collections
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        queue = collections.deque()
        if root:
            queue.append(root)
        result = 0
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                result += 1 #记录节点数量
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return result

# 完全二叉树
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        left = root.left
        right = root.right
        leftHeight = 0 #这里初始为0是有目的的，为了下面求指数方便
        rightHeight = 0
        while left: #求左子树深度
            left = left.left
            leftHeight += 1
        while right: #求右子树深度
            right = right.right
            rightHeight += 1
        if leftHeight == rightHeight:
            return (2 << leftHeight) - 1 #注意(2<<1) 相当于2^2，所以leftHeight初始为0
        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

## 平衡二叉树【未】

一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

## 二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。

```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        res = []
        path = []

        def back_track(root):
            if not root:
                return
            
            path.append(str(root.val))
            if not root.left and not root.right:
                res.append("->".join(path[:]))
                path.pop()
                return
            
            if root.left:
                back_track(root.left)

            if root.right:
                back_track(root.right)

            path.pop()
        
        back_track(root)

        return res
```

## 左叶子之和

左叶子定义：**如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子**

```python
# 递归
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root: 
            return 0
        
        left_left_leaves_sum = self.sumOfLeftLeaves(root.left)  # 左
        right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # 右
        
        cur_left_leaf_val = 0
        if root.left and not root.left.left and not root.left.right: 
            cur_left_leaf_val = root.left.val  # 中
            
        return cur_left_leaf_val + left_left_leaves_sum + right_left_leaves_sum

# 迭代
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        """
        Idea: Each time check current node's left node. 
              If current node don't have one, skip it. 
        """
        stack = []
        if root: 
            stack.append(root)
        res = 0
        
        while stack: 
            # 每次都把当前节点的左节点加进去. 
            cur_node = stack.pop()
            if cur_node.left and not cur_node.left.left and not cur_node.left.right: 
                res += cur_node.left.val
                
            if cur_node.left: 
                stack.append(cur_node.left)
            if cur_node.right: 
                stack.append(cur_node.right)
                
        return res
```

## 找到左下角的值

本题重点是**找到最后一层最左边的元素**。一直找最左边的值，不一定能得到答案，因为不一定能走到二叉树的最后一层。

针对这题，最好就是做`层序遍历`，选择最后一层的第一个元素即可

```python
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        queue = deque()
        if root: 
            queue.append(root)
        result = 0
        while queue: 
            q_len = len(queue)
            for i in range(q_len): 
                if i == 0: 
                    result = queue[i].val 
                cur = queue.popleft()
                if cur.left: 
                    queue.append(cur.left)
                if cur.right: 
                    queue.append(cur.right)
        return result
```

## 路径总和

回溯算法

```python
class solution:
    def haspathsum(self, root: treenode, targetsum: int) -> bool:
        def isornot(root, targetsum) -> bool:
            if (not root.left) and (not root.right) and targetsum == 0:
                return true  # 遇到叶子节点，并且计数为0
            if (not root.left) and (not root.right):
                return false  # 遇到叶子节点，计数不为0
            if root.left:
                targetsum -= root.left.val  # 左节点
                if isornot(root.left, targetsum): return true  # 递归，处理左节点
                targetsum += root.left.val  # 回溯
            if root.right:
                targetsum -= root.right.val  # 右节点
                if isornot(root.right, targetsum): return true  # 递归，处理右节点
                targetsum += root.right.val  # 回溯
            return false

        if root == none:
            return false  # 别忘记处理空treenode
        else:
            return isornot(root, targetsum - root.val)
```

## 路径总和II

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        path = []
        res = []

        def back_track(target, sumNum, root):
            if not root:
                return 

            sumNum = sumNum + root.val
            path.append(root.val)

            if not root.left and not root.right and sumNum == target:
                res.append(path[:])
            
            if root.left:
                back_track(target, sumNum, root.left)

            if root.right:
                back_track(target, sumNum, root.right)

            sumNum = sumNum - root.val
            path.pop()
        
        back_track(targetSum, 0, root)
        return res
```





# 回溯算法

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

## 相关问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。

## 模板（回溯三部曲）

- 回溯函数模板返回值以及参数
- 回溯函数终止条件
- 回溯搜索的遍历过程

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题

回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。

递归来做层叠嵌套（可以理解是开k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度**。

那么如何在这个树上遍历，然后收集到我们要的结果集呢？

**图中每次搜索到了叶子节点，我们就找到了一个结果**。

相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res=[]  #存放符合条件结果的集合
        path=[]  #用来存放符合条件结果
        def backtrack(n,k,startIndex):
            if len(path) == k:
                res.append(path[:])
                return 
            for i in range(startIndex,n+1):
                path.append(i)  #处理节点 
                backtrack(n,k,i+1)  #递归
                path.pop()  #回溯，撤销处理的节点
        backtrack(n,k,1)
        return res
```

## 组合总和III

相比上一题，添加了限制条件

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []  #存放结果集
        path = []  #符合条件的结果
        def findallPath(n,k,sum,startIndex):
            if sum > n: return  #剪枝操作
            if sum == n and len(path) == k:  #如果path.size() == k 但sum != n 直接返回
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #剪枝操作
                path.append(i)
                sum += i 
                findallPath(n,k,sum,i+1)  #注意i+1调整startIndex
                sum -= i  #回溯
                path.pop()  #回溯
        
        findallPath(n,k,0,1)
        return res
```

## 电话号码的字母组合

```python
class Solution:
    ans = []
    s = ''
    letterMap = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    }

    def letterCombinations(self, digits):
        self.ans.clear()
        if digits == '':
            return self.ans
        self.backtracking(digits, 0)
        return self.ans

    def backtracking(self, digits, index):
        if index == len(digits):
            self.ans.append(self.s)
            return
        else:
            letters = self.letterMap[digits[index]]  # 取出数字对应的字符集
            for letter in letters:
                self.s = self.s + letter  # 处理
                self.backtracking(digits, index + 1)
                self.s = self.s[:-1]      # 回溯
```

## 组合总和

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(candidates,target,sum,startIndex):
            if sum > target: return 
            if sum == target: return res.append(path[:])
            for i in range(startIndex,len(candidates)):
                if sum + candidates[i] >target: return  #如果 sum + candidates[i] > target 就终止遍历
                sum += candidates[i] 
                path.append(candidates[i])
                backtrack(candidates,target,sum,i)  #startIndex = i:表示可以重复读取当前的数
                sum -= candidates[i]  #回溯
                path.pop()  #回溯
        candidates = sorted(candidates)  #需要排序
        backtrack(candidates,target,0,0)
        return res
```

## 组合总和

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。

解决方法：另外再设一个`bool`型数组`used`，同一层的重复元素要跳过。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]。**此时for循环里就应该做continue的操作。

我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树支candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

这里直接用startIndex来去重也是可以的， 就不用used数组了。

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(candidates,target,sum,startIndex):
            if sum == target: res.append(path[:])
            for i in range(startIndex,len(candidates)):  #要对同一树层使用过的元素进行跳过
                if sum + candidates[i] > target: return 
                if i > startIndex and candidates[i] == candidates[i-1]: continue  #直接用startIndex来去重,要对同一树层使用过的元素进行跳过
                sum += candidates[i]
                path.append(candidates[i])
                backtrack(candidates,target,sum,i+1)  #i+1:每个数字在每个组合中只能使用一次
                sum -= candidates[i]  #回溯
                path.pop()  #回溯
        candidates = sorted(candidates)  #首先把给candidates排序，让其相同的元素都挨在一起。
        backtrack(candidates,target,0,0)
        return res
```

## 分割回文串

# 贪心算法

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

**贪心没有套路，说白了就是常识性推导加上举反例**。

## 分发饼干



# 动态规划

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 斐波那契数

递推公式：`dp[i] = dp[i-1] + dp[i-2]`，`dp[i]`表示第`i`个位置的斐波那契数

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        a, b, c = 0, 1, 0
        for i in range(1, n):
            c = a + b
            a, b = b, c
        return c

# 递归实现
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
```

## 爬楼梯

递推公式：`dp[i] = dp[i-1] + dp[i-2]`，`dp[i]`表示能到达第`i`个位置的方法数。由于第`i`个位置只有通过第`i-1`和第`i-2`个位置才能达到，所以只要把这两个位置的方法数相加即可

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # dp[i]表示爬到第i级楼梯的种数， (1, 2) (2, 1)是两种不同的类型
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(n+1):
            for j in range(1, 3):
                if i>=j:
                    dp[i] += dp[i-j]
        return dp[-1]
```

## 使用最小花费爬楼梯

递推公式：`dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`，`dp[i]`表示到达第`i`个位置所需要的花费

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost) + 1)

        for i in range(2, len(cost)+1):
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
        
        return dp[-1]
```

## 不同路径

题目规定只能向右或向下，因此只要保证遍历顺序严格按照从左上到右下即可。

递推公式：`dp[i][j] = dp[i][j-1] + dp[i-1][j]`，`dp[i][j]`表示从起点到`[i][j]`处的可能路径数。

初始化：`dp[i][0]=1`和`dp[0][j]` = 1

```python
class Solution: # 动态规划
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1 for i in range(n)] for j in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
        return dp[m - 1][n - 1]
```

## 不同路径II

加入了障碍物，但思路与上题相同

如果`[i][j]`处是障碍物，则不可能有路径能到达，不处理即可

如果在第一行或者第一列上有障碍物，则在障碍物之前的位置均有一条路径可到达，而后面的位置则无路径到达

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # 构造一个DP table
        row = len(obstacleGrid)
        col = len(obstacleGrid[0])
        dp = [[0 for _ in range(col)] for _ in range(row)]

        dp[0][0] = 1 if obstacleGrid[0][0] != 1 else 0
        if dp[0][0] == 0: return 0  # 如果第一个格子就是障碍，return 0
        # 第一行
        for i in range(1, col):
            if obstacleGrid[0][i] != 1:
                dp[0][i] = dp[0][i-1]

        # 第一列
        for i in range(1, row):
            if obstacleGrid[i][0] != 1:
                dp[i][0] = dp[i-1][0]
        print(dp)

        for i in range(1, row):
            for j in range(1, col):
                if obstacleGrid[i][j] != 1:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

## 整数拆分

